/*!
 *         ,/
 *       ,'/
 *     ,' /
 *   ,'  /_____,
 * .'____    ,'
 *      /  ,'
 *     / ,'
 *    /,'
 *   /'
 *
 * Selectric ÏŸ v1.11.1 (Jan 10 2017) - http://lcdsantos.github.io/jQuery-Selectric/
 *
 * Copyright (c) 2017 Leonardo Santos; MIT License
 *
 */





// Modified for Konversion Theme
// added option `direction: top / bottom` for options to only drop to the up or down





(function(factory) {
  /* global define */
  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node/CommonJS
    module.exports = function(root, jQuery) {
      if (jQuery === undefined) {
        if (typeof window !== 'undefined') {
          jQuery = require('jquery');
        } else {
          jQuery = require('jquery')(root);
        }
      }
      factory(jQuery);
      return jQuery;
    };
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function($) {
  'use strict';

  var $doc = $(document);
  var $win = $(window);

  var pluginName = 'selectric';
  var classList = 'Input Items Open Disabled TempShow HideSelect Wrapper Focus Hover Responsive Above Scroll Group GroupLabel';
  var eventNamespaceSuffix = '.sl';

  var chars = ['a', 'e', 'i', 'o', 'u', 'n', 'c', 'y'];
  var diacritics = [
    /[\xE0-\xE5]/g, // a
    /[\xE8-\xEB]/g, // e
    /[\xEC-\xEF]/g, // i
    /[\xF2-\xF6]/g, // o
    /[\xF9-\xFC]/g, // u
    /[\xF1]/g, // n
    /[\xE7]/g, // c
    /[\xFD-\xFF]/g // y
  ];

  /**
   * Create an instance of Selectric
   *
   * @constructor
   * @param {Node} element - The &lt;select&gt; element
   * @param {object}  opts - Options
   */
  var Selectric = function(element, opts) {
    var _this = this;

    _this.element = element;
    _this.$element = $(element);

    _this.state = {
      multiple: !!_this.$element.attr('multiple'),
      enabled: false,
      opened: false,
      currValue: -1,
      selectedIdx: -1,
      highlightedIdx: -1
    };

    _this.eventTriggers = {
      open: _this.open,
      close: _this.close,
      destroy: _this.destroy,
      refresh: _this.refresh,
      init: _this.init
    };

    _this.init(opts);
  };

  Selectric.prototype = {
    utils: {
      /**
       * Detect mobile browser
       *
       * @return {boolean}
       */
      isMobile: function() {
        return /android|ip(hone|od|ad)/i.test(navigator.userAgent);
      },

      /**
       * Escape especial characters in string (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
       *
       * @param  {string} str - The string to be escaped
       * @return {string}       The string with the special characters escaped
       */
      escapeRegExp: function(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
      },

      /**
       * Replace diacritics
       *
       * @param  {string} str - The string to replace the diacritics
       * @return {string}       The string with diacritics replaced with ascii characters
       */
      replaceDiacritics: function(str) {
        var k = diacritics.length;

        while (k--) {
          str = str.toLowerCase().replace(diacritics[k], chars[k]);
        }

        return str;
      },

      /**
       * Format string
       * https://gist.github.com/atesgoral/984375
       *
       * @param  {string} f - String to be formated
       * @return {string}     String formated
       */
      format: function(f) {
        var a = arguments; // store outer arguments
        return ('' + f) // force format specifier to String
          .replace( // replace tokens in format specifier
            /\{(?:(\d+)|(\w+))\}/g, // match {token} references
            function(
              s, // the matched string (ignored)
              i, // an argument index
              p // a property name
            ) {
              return p && a[1] // if property name and first argument exist
                ?
                a[1][p] // return property from first argument
                :
                a[i]; // assume argument index and return i-th argument
            });
      },

      /**
       * Get the next enabled item in the options list.
       *
       * @param  {object} selectItems - The options object.
       * @param  {number}    selected - Index of the currently selected option.
       * @return {object}               The next enabled item.
       */
      nextEnabledItem: function(selectItems, selected) {
        while (selectItems[selected = (selected + 1) % selectItems.length].disabled) {
          // empty
        }
        return selected;
      },

      /**
       * Get the previous enabled item in the options list.
       *
       * @param  {object} selectItems - The options object.
       * @param  {number}    selected - Index of the currently selected option.
       * @return {object}               The previous enabled item.
       */
      previousEnabledItem: function(selectItems, selected) {
        while (selectItems[selected = (selected > 0 ? selected : selectItems.length) - 1].disabled) {
          // empty
        }
        return selected;
      },

      /**
       * Transform camelCase string to dash-case.
       *
       * @param  {string} str - The camelCased string.
       * @return {string}       The string transformed to dash-case.
       */
      toDash: function(str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      },

      /**
       * Calls the events registered with function name.
       *
       * @param {string}    fn - The name of the function.
       * @param {number} scope - Scope that should be set on the function.
       */
      triggerCallback: function(fn, scope) {
        var elm = scope.element;
        var func = scope.options['on' + fn];
        var args = [elm].concat([].slice.call(arguments).slice(1));

        if ($.isFunction(func)) {
          func.apply(elm, args);
        }

        $(elm).trigger(pluginName + '-' + this.toDash(fn), args);
      },

      /**
       * Transform array list to concatenated string and remove empty values
       * @param  {array} arr - Class list
       * @return {string}      Concatenated string
       */
      arrayToClassname: function(arr) {
        var newArr = $.grep(arr, function(item) {
          return !!item;
        });

        return $.trim(newArr.join(' '));
      }
    },

    /** Initializes */
    init: function(opts) {
      var _this = this;

      // Set options
      _this.options = $.extend(true, {}, $.fn[pluginName].defaults, _this.options, opts);

      _this.utils.triggerCallback('BeforeInit', _this);

      // Preserve data
      _this.destroy(true);

      // Disable on mobile browsers
      if (_this.options.disableOnMobile && _this.utils.isMobile()) {
        _this.disableOnMobile = true;
        return;
      }

      // Get classes
      _this.classes = _this.getClassNames();

      // Create elements
      var input = $('<input/>', { 'class': _this.classes.input, 'readonly': _this.utils.isMobile() });
      var items = $('<div/>', { 'class': _this.classes.items, 'tabindex': -1 });
      var itemsScroll = $('<div/>', { 'class': _this.classes.scroll });
      var wrapper = $('<div/>', { 'class': _this.classes.prefix, 'html': _this.options.arrowButtonMarkup });
      var label = $('<span/>', { 'class': 'label' });
      var outerWrapper = _this.$element.wrap('<div/>').parent().append(wrapper.prepend(label), items, input);
      var hideSelectWrapper = $('<div/>', { 'class': _this.classes.hideselect });

      _this.elements = {
        input: input,
        items: items,
        itemsScroll: itemsScroll,
        wrapper: wrapper,
        label: label,
        outerWrapper: outerWrapper
      };

      if (_this.options.nativeOnMobile && _this.utils.isMobile()) {
        _this.elements.input = undefined;
        hideSelectWrapper.addClass(_this.classes.prefix + '-is-native');

        _this.$element.on('change', function() {
          _this.refresh();
        });
      }

      _this.$element
        .on(_this.eventTriggers)
        .wrap(hideSelectWrapper);

      _this.originalTabindex = _this.$element.prop('tabindex');
      _this.$element.prop('tabindex', -1);

      _this.populate();
      _this.activate();

      _this.utils.triggerCallback('Init', _this);
    },

    /** Activates the plugin */
    activate: function() {
      var _this = this;
      var hiddenChildren = _this.elements.items.closest(':visible').children(':hidden').addClass(_this.classes.tempshow);
      var originalWidth = _this.$element.width();

      hiddenChildren.removeClass(_this.classes.tempshow);

      _this.utils.triggerCallback('BeforeActivate', _this);

      _this.elements.outerWrapper.prop('class',
        _this.utils.arrayToClassname([
          _this.classes.wrapper,
          _this.$element.prop('class').replace(/\S+/g, _this.classes.prefix + '-$&'),
          _this.options.responsive ? _this.classes.responsive : ''
        ])
      );

      if (_this.options.inheritOriginalWidth && originalWidth > 0) {
        _this.elements.outerWrapper.width(originalWidth);
      }

      _this.unbindEvents();

      if (!_this.$element.prop('disabled')) {
        _this.state.enabled = true;

        // Not disabled, so... Removing disabled class
        _this.elements.outerWrapper.removeClass(_this.classes.disabled);

        // Remove styles from items box
        // Fix incorrect height when refreshed is triggered with fewer options
        _this.$li = _this.elements.items.removeAttr('style').find('li');

        _this.bindEvents();
      } else {
        _this.elements.outerWrapper.addClass(_this.classes.disabled);

        if (_this.elements.input) {
          _this.elements.input.prop('disabled', true);
        }
      }

      _this.utils.triggerCallback('Activate', _this);
    },

    /**
     * Generate classNames for elements
     *
     * @return {object} Classes object
     */
    getClassNames: function() {
      var _this = this;
      var customClass = _this.options.customClass;
      var classesObj = {};

      $.each(classList.split(' '), function(i, currClass) {
        var c = customClass.prefix + currClass;
        classesObj[currClass.toLowerCase()] = customClass.camelCase ? c : _this.utils.toDash(c);
      });

      classesObj.prefix = customClass.prefix;

      return classesObj;
    },

    /** Set the label text */
    setLabel: function() {
      var _this = this;
      var labelBuilder = _this.options.labelBuilder;

      if (_this.state.multiple) {
        // Make sure currentValues is an array
        var currentValues = $.isArray(_this.state.currValue) ? _this.state.currValue : [_this.state.currValue];
        // I'm not happy with this, but currentValues can be an empty
        // array and we need to fallback to the default option.
        currentValues = currentValues.length === 0 ? [0] : currentValues;

        var labelMarkup = $.map(currentValues, function(value) {
          return $.grep(_this.lookupItems, function(item) {
            return item.index === value;
          })[0]; // we don't want nested arrays here
        });

        labelMarkup = $.grep(labelMarkup, function(item) {
          // Hide default (please choose) if more then one element were selected.
          // If no option value were given value is set to option text by default
          if (labelMarkup.length > 1 || labelMarkup.length === 0) {
            return $.trim(item.value) !== '';
          }
          return item;
        });

        labelMarkup = $.map(labelMarkup, function(item) {
          return $.isFunction(labelBuilder) ?
            labelBuilder(item) :
            _this.utils.format(labelBuilder, item);
        });

        // Limit the amount of selected values shown in label
        if (_this.options.multiple.maxLabelEntries) {
          if (labelMarkup.length >= _this.options.multiple.maxLabelEntries + 1) {
            labelMarkup = labelMarkup.slice(0, _this.options.multiple.maxLabelEntries);
            labelMarkup.push(
              $.isFunction(labelBuilder) ?
              labelBuilder({ text: '...' }) :
              _this.utils.format(labelBuilder, { text: '...' }));
          } else {
            labelMarkup.slice(labelMarkup.length - 1);
          }
        }
        _this.elements.label.html(labelMarkup.join(_this.options.multiple.separator));

      } else {
        var currItem = _this.lookupItems[_this.state.currValue];

        _this.elements.label.html(
          $.isFunction(labelBuilder) ?
          labelBuilder(currItem) :
          _this.utils.format(labelBuilder, currItem)
        );
      }
    },

    /** Get and save the available options */
    populate: function() {
      var _this = this;
      var $options = _this.$element.children();
      var $justOptions = _this.$element.find('option');
      var $selected = $justOptions.filter(':selected');
      var selectedIndex = $justOptions.index($selected);
      var currIndex = 0;
      var emptyValue = (_this.state.multiple ? [] : 0);

      if ($selected.length > 1 && _this.state.multiple) {
        selectedIndex = [];
        $selected.each(function() {
          selectedIndex.push($(this).index());
        });
      }

      _this.state.currValue = (~selectedIndex ? selectedIndex : emptyValue);
      _this.state.selectedIdx = _this.state.currValue;
      _this.state.highlightedIdx = _this.state.currValue;
      _this.items = [];
      _this.lookupItems = [];

      if ($options.length) {
        // Build options markup
        $options.each(function(i) {
          var $elm = $(this);

          if ($elm.is('optgroup')) {

            var optionsGroup = {
              element: $elm,
              label: $elm.prop('label'),
              groupDisabled: $elm.prop('disabled'),
              items: []
            };

            $elm.children().each(function(i) {
              var $elm = $(this);

              optionsGroup.items[i] = _this.getItemData(currIndex, $elm, optionsGroup.groupDisabled || $elm.prop('disabled'));

              _this.lookupItems[currIndex] = optionsGroup.items[i];

              currIndex++;
            });

            _this.items[i] = optionsGroup;

          } else {

            _this.items[i] = _this.getItemData(currIndex, $elm, $elm.prop('disabled'));

            _this.lookupItems[currIndex] = _this.items[i];

            currIndex++;

          }
        });

        _this.setLabel();
        _this.elements.items.append(_this.elements.itemsScroll.html(_this.getItemsMarkup(_this.items)));
      }
    },

    /**
     * Generate items object data
     * @param  {integer} index      - Current item index
     * @param  {node}    $elm       - Current element node
     * @param  {boolean} isDisabled - Current element disabled state
     * @return {object}               Item object
     */
    getItemData: function(index, $elm, isDisabled) {
      var _this = this;

      return {
        index: index,
        element: $elm,
        value: $elm.val(),
        className: $elm.prop('class'),
        text: $elm.html(),
        slug: $.trim(_this.utils.replaceDiacritics($elm.html())),
        selected: $elm.prop('selected'),
        disabled: isDisabled
      };
    },

    /**
     * Generate options markup
     *
     * @param  {object} items - Object containing all available options
     * @return {string}         HTML for the options box
     */
    getItemsMarkup: function(items) {
      var _this = this;
      var markup = '<ul>';

      if ($.isFunction(_this.options.listBuilder) && _this.options.listBuilder) {
        items = _this.options.listBuilder(items);
      }

      $.each(items, function(i, elm) {
        if (elm.label !== undefined) {

          markup += _this.utils.format('<ul class="{1}"><li class="{2}">{3}</li>',
            _this.utils.arrayToClassname([
              _this.classes.group,
              elm.groupDisabled ? 'disabled' : '',
              elm.element.prop('class')
            ]),
            _this.classes.grouplabel,
            elm.element.prop('label')
          );

          $.each(elm.items, function(i, elm) {
            markup += _this.getItemMarkup(elm.index, elm);
          });

          markup += '</ul>';

        } else {

          markup += _this.getItemMarkup(elm.index, elm);

        }
      });

      return markup + '</ul>';
    },

    /**
     * Generate every option markup
     *
     * @param  {number} index    - Index of current item
     * @param  {object} itemData - Current item
     * @return {string}            HTML for the option
     */
    getItemMarkup: function(index, itemData) {
      var _this = this;
      var itemBuilder = _this.options.optionsItemBuilder;
      // limit access to item data to provide a simple interface
      // to most relevant options.
      var filteredItemData = {
        value: itemData.value,
        text: itemData.text,
        slug: itemData.slug,
        index: itemData.index
      };

      return _this.utils.format('<li data-index="{1}" class="{2}">{3}</li>',
        index,
        _this.utils.arrayToClassname([
          itemData.className,
          index === _this.items.length - 1 ? 'last' : '',
          itemData.disabled ? 'disabled' : '',
          itemData.selected ? 'selected' : ''
        ]),
        $.isFunction(itemBuilder) ?
        _this.utils.format(itemBuilder(itemData), itemData) :
        _this.utils.format(itemBuilder, filteredItemData)
      );
    },

    /** Remove events on the elements */
    unbindEvents: function() {
      var _this = this;

      _this.elements.wrapper
        .add(_this.$element)
        .add(_this.elements.outerWrapper)
        .add(_this.elements.input)
        .off(eventNamespaceSuffix);
    },

    /** Bind events on the elements */
    bindEvents: function() {
      var _this = this;

      _this.elements.outerWrapper.on('mouseenter' + eventNamespaceSuffix + ' mouseleave' + eventNamespaceSuffix, function(e) {
        $(this).toggleClass(_this.classes.hover, e.type === 'mouseenter');

        // Delay close effect when openOnHover is true
        if (_this.options.openOnHover) {
          clearTimeout(_this.closeTimer);

          if (e.type === 'mouseleave') {
            _this.closeTimer = setTimeout($.proxy(_this.close, _this), _this.options.hoverIntentTimeout);
          } else {
            _this.open();
          }
        }
      });

      // Toggle open/close
      _this.elements.wrapper.on('click' + eventNamespaceSuffix, function(e) {
        _this.state.opened ? _this.close() : _this.open(e);
      });

      // Translate original element focus event to dummy input.
      // Disabled on mobile devices because the default option list isn't
      // shown due the fact that hidden input gets focused
      if (!(_this.options.nativeOnMobile && _this.utils.isMobile())) {
        _this.$element.on('focus' + eventNamespaceSuffix, function() {
          _this.elements.input.focus();
        });

        _this.elements.input
          .prop({ tabindex: _this.originalTabindex, disabled: false })
          .on('keydown' + eventNamespaceSuffix, $.proxy(_this.handleKeys, _this))
          .on('focusin' + eventNamespaceSuffix, function(e) {
            _this.elements.outerWrapper.addClass(_this.classes.focus);

            // Prevent the flicker when focusing out and back again in the browser window
            _this.elements.input.one('blur', function() {
              _this.elements.input.blur();
            });

            if (_this.options.openOnFocus && !_this.state.opened) {
              _this.open(e);
            }
          })
          .on('focusout' + eventNamespaceSuffix, function() {
            _this.elements.outerWrapper.removeClass(_this.classes.focus);
          })
          .on('input propertychange', function() {
            var val = _this.elements.input.val();
            var searchRegExp = new RegExp('^' + _this.utils.escapeRegExp(val), 'i');

            // Clear search
            clearTimeout(_this.resetStr);
            _this.resetStr = setTimeout(function() {
              _this.elements.input.val('');
            }, _this.options.keySearchTimeout);

            if (val.length) {
              // Search in select options
              $.each(_this.items, function(i, elm) {
                if (!elm.disabled && searchRegExp.test(elm.text) || searchRegExp.test(elm.slug)) {
                  _this.highlight(i);
                  return;
                }
              });
            }
          });
      }

      _this.$li.on({
        // Prevent <input> blur on Chrome
        mousedown: function(e) {
          e.preventDefault();
          e.stopPropagation();
        },
        click: function() {
          _this.select($(this).data('index'));

          // Chrome doesn't close options box if select is wrapped with a label
          // We need to 'return false' to avoid that
          return false;
        }
      });
    },

    /**
     * Behavior when keyboard keys is pressed
     *
     * @param {object} e - Event object
     */
    handleKeys: function(e) {
      var _this = this;
      var key = e.which;
      var keys = _this.options.keys;

      var isPrevKey = $.inArray(key, keys.previous) > -1;
      var isNextKey = $.inArray(key, keys.next) > -1;
      var isSelectKey = $.inArray(key, keys.select) > -1;
      var isOpenKey = $.inArray(key, keys.open) > -1;
      var idx = _this.state.highlightedIdx;
      var isFirstOrLastItem = (isPrevKey && idx === 0) || (isNextKey && (idx + 1) === _this.items.length);
      var goToItem = 0;

      // Enter / Space
      if (key === 13 || key === 32) {
        e.preventDefault();
      }

      // If it's a directional key
      if (isPrevKey || isNextKey) {
        if (!_this.options.allowWrap && isFirstOrLastItem) {
          return;
        }

        if (isPrevKey) {
          goToItem = _this.utils.previousEnabledItem(_this.lookupItems, idx);
        }

        if (isNextKey) {
          goToItem = _this.utils.nextEnabledItem(_this.lookupItems, idx);
        }

        _this.highlight(goToItem);
      }

      // Tab / Enter / ESC
      if (isSelectKey && _this.state.opened) {
        _this.select(idx);

        if (!_this.state.multiple || !_this.options.multiple.keepMenuOpen) {
          _this.close();
        }

        return;
      }

      // Space / Enter / Left / Up / Right / Down
      if (isOpenKey && !_this.state.opened) {
        _this.open();
      }
    },

    /** Update the items object */
    refresh: function() {
      var _this = this;

      _this.populate();
      _this.activate();
      _this.utils.triggerCallback('Refresh', _this);
    },

    /** Set options box width/height */
    setOptionsDimensions: function() {
      var _this = this;

      // Calculate options box height
      // Set a temporary class on the hidden parent of the element
      var hiddenChildren = _this.elements.items.closest(':visible').children(':hidden').addClass(_this.classes.tempshow);
      var maxHeight = _this.options.maxHeight;
      var itemsWidth = _this.elements.items.outerWidth();
      var wrapperWidth = _this.elements.wrapper.outerWidth() - (itemsWidth - _this.elements.items.width());

      // Set the dimensions, minimum is wrapper width, expand for long items if option is true
      if (!_this.options.expandToItemText || wrapperWidth > itemsWidth) {
        _this.finalWidth = wrapperWidth;
      } else {
        // Make sure the scrollbar width is included
        _this.elements.items.css('overflow', 'scroll');

        // Set a really long width for _this.elements.outerWrapper
        _this.elements.outerWrapper.width(9e4);
        _this.finalWidth = _this.elements.items.width();
        // Set scroll bar to auto
        _this.elements.items.css('overflow', '');
        _this.elements.outerWrapper.width('');
      }

      _this.elements.items.width(_this.finalWidth).height() > maxHeight && _this.elements.items.height(maxHeight);

      // Remove the temporary class
      hiddenChildren.removeClass(_this.classes.tempshow);
    },

    /** Detect if the options box is inside the window */
    isInViewport: function() {
      var _this = this;
      var scrollTop = $win.scrollTop();
      var winHeight = $win.height();
      var uiPosX = _this.elements.outerWrapper.offset().top;
      var uiHeight = _this.elements.outerWrapper.outerHeight();

      var fitsDown = _this.options.direction != 'top' && (uiPosX + uiHeight + _this.itemsHeight) <= (scrollTop + winHeight);
      var fitsAbove = _this.options.direction != 'bottom' && (uiPosX - _this.itemsHeight) > scrollTop;

      // If it does not fit below, only render it
      // above it fit's there.
      // It's acceptable that the user needs to
      // scroll the viewport to see the cut off UI
      var renderAbove = !fitsDown && fitsAbove;

      _this.elements.outerWrapper.toggleClass(_this.classes.above, renderAbove);
    },

    /**
     * Detect if currently selected option is visible and scroll the options box to show it
     *
     * @param {Number|Array} index - Index of the selected items
     */
    detectItemVisibility: function(index) {
      var _this = this;
      var $filteredLi = _this.$li.filter('[data-index]');

      if (_this.state.multiple) {
        // If index is an array, we can assume a multiple select and we
        // want to scroll to the uppermost selected item!
        // Math.min.apply(Math, index) returns the lowest entry in an Array.
        index = ($.isArray(index) && index.length === 0) ? 0 : index;
        index = $.isArray(index) ? Math.min.apply(Math, index) : index;
      }

      var liHeight = $filteredLi.eq(index).outerHeight();
      var liTop = $filteredLi[index].offsetTop;
      var itemsScrollTop = _this.elements.itemsScroll.scrollTop();
      var scrollT = liTop + liHeight * 2;

      _this.elements.itemsScroll.scrollTop(
        scrollT > itemsScrollTop + _this.itemsHeight ? scrollT - _this.itemsHeight :
        liTop - liHeight < itemsScrollTop ? liTop - liHeight :
        itemsScrollTop
      );
    },

    /**
     * Open the select options box
     *
     * @param {Event} e - Event
     */
    open: function(e) {
      var _this = this;

      if (_this.options.nativeOnMobile && _this.utils.isMobile()) {
        return false;
      }

      _this.utils.triggerCallback('BeforeOpen', _this);

      if (e) {
        e.preventDefault();
        if (_this.options.stopPropagation) {
          e.stopPropagation();
        }
      }

      if (_this.state.enabled) {
        _this.setOptionsDimensions();

        // Find any other opened instances of select and close it
        $('.' + _this.classes.hideselect, '.' + _this.classes.open).children()[pluginName]('close');

        _this.state.opened = true;
        _this.itemsHeight = _this.elements.items.outerHeight();
        _this.itemsInnerHeight = _this.elements.items.height();

        // Toggle options box visibility
        _this.elements.outerWrapper.addClass(_this.classes.open);

        // Give dummy input focus
        _this.elements.input.val('');
        if (e && e.type !== 'focusin') {
          _this.elements.input.focus();
        }

        // Delayed binds events on Document to make label clicks work
        setTimeout(function() {
          $doc
            .on('click' + eventNamespaceSuffix, $.proxy(_this.close, _this))
            .on('scroll' + eventNamespaceSuffix, $.proxy(_this.isInViewport, _this));
        }, 1);

        _this.isInViewport();

        // Prevent window scroll when using mouse wheel inside items box
        if (_this.options.preventWindowScroll) {
          /* istanbul ignore next */
          $doc.on('mousewheel' + eventNamespaceSuffix + ' DOMMouseScroll' + eventNamespaceSuffix, '.' + _this.classes.scroll, function(e) {
            var orgEvent = e.originalEvent;
            var scrollTop = $(this).scrollTop();
            var deltaY = 0;

            if ('detail' in orgEvent) { deltaY = orgEvent.detail * -1; }
            if ('wheelDelta' in orgEvent) { deltaY = orgEvent.wheelDelta; }
            if ('wheelDeltaY' in orgEvent) { deltaY = orgEvent.wheelDeltaY; }
            if ('deltaY' in orgEvent) { deltaY = orgEvent.deltaY * -1; }

            if (scrollTop === (this.scrollHeight - _this.itemsInnerHeight) && deltaY < 0 || scrollTop === 0 && deltaY > 0) {
              e.preventDefault();
            }
          });
        }

        _this.detectItemVisibility(_this.state.selectedIdx);

        _this.highlight(_this.state.multiple ? -1 : _this.state.selectedIdx);

        _this.utils.triggerCallback('Open', _this);
      }
    },

    /** Close the select options box */
    close: function() {
      var _this = this;

      _this.utils.triggerCallback('BeforeClose', _this);

      // Remove custom events on document
      $doc.off(eventNamespaceSuffix);

      // Remove visible class to hide options box
      _this.elements.outerWrapper.removeClass(_this.classes.open);

      _this.state.opened = false;

      _this.utils.triggerCallback('Close', _this);
    },

    /** Select current option and change the label */
    change: function() {
      var _this = this;

      _this.utils.triggerCallback('BeforeChange', _this);

      if (_this.state.multiple) {
        // Reset old selected
        $.each(_this.lookupItems, function(idx) {
          _this.lookupItems[idx].selected = false;
          _this.$element.find('option').prop('selected', false);
        });

        // Set new selected
        $.each(_this.state.selectedIdx, function(idx, value) {
          _this.lookupItems[value].selected = true;
          _this.$element.find('option').eq(value).prop('selected', true);
        });

        _this.state.currValue = _this.state.selectedIdx;

        _this.setLabel();

        _this.utils.triggerCallback('Change', _this);
      } else if (_this.state.currValue !== _this.state.selectedIdx) {
        // Apply changed value to original select
        _this.$element
          .prop('selectedIndex', _this.state.currValue = _this.state.selectedIdx)
          .data('value', _this.lookupItems[_this.state.selectedIdx].text);

        // Change label text
        _this.setLabel();

        _this.utils.triggerCallback('Change', _this);
      }
    },

    /**
     * Highlight option
     * @param {number} index - Index of the options that will be highlighted
     */
    highlight: function(index) {
      var _this = this;
      var $filteredLi = _this.$li.filter('[data-index]').removeClass('highlighted');

      _this.utils.triggerCallback('BeforeHighlight', _this);

      // Parameter index is required and should not be a disabled item
      if (index === undefined || index === -1 || _this.lookupItems[index].disabled) {
        return;
      }

      $filteredLi
        .eq(_this.state.highlightedIdx = index)
        .addClass('highlighted');

      _this.detectItemVisibility(index);

      _this.utils.triggerCallback('Highlight', _this);
    },

    /**
     * Select option
     *
     * @param {number} index - Index of the option that will be selected
     */
    select: function(index) {
      var _this = this;
      var $filteredLi = _this.$li.filter('[data-index]');

      _this.utils.triggerCallback('BeforeSelect', _this, index);

      // Parameter index is required and should not be a disabled item
      if (index === undefined || index === -1 || _this.lookupItems[index].disabled) {
        return;
      }

      if (_this.state.multiple) {
        // Make sure selectedIdx is an array
        _this.state.selectedIdx = $.isArray(_this.state.selectedIdx) ? _this.state.selectedIdx : [_this.state.selectedIdx];

        var hasSelectedIndex = $.inArray(index, _this.state.selectedIdx);
        if (hasSelectedIndex !== -1) {
          _this.state.selectedIdx.splice(hasSelectedIndex, 1);
        } else {
          _this.state.selectedIdx.push(index);
        }

        $filteredLi
          .removeClass('selected')
          .filter(function(index) {
            return $.inArray(index, _this.state.selectedIdx) !== -1;
          })
          .addClass('selected');
      } else {
        $filteredLi
          .removeClass('selected')
          .eq(_this.state.selectedIdx = index)
          .addClass('selected');
      }

      if (!_this.state.multiple || !_this.options.multiple.keepMenuOpen) {
        _this.close();
      }

      _this.change();

      _this.utils.triggerCallback('Select', _this, index);
    },

    /**
     * Unbind and remove
     *
     * @param {boolean} preserveData - Check if the data on the element should be removed too
     */
    destroy: function(preserveData) {
      var _this = this;

      if (_this.state && _this.state.enabled) {
        _this.elements.items.add(_this.elements.wrapper).add(_this.elements.input).remove();

        if (!preserveData) {
          _this.$element.removeData(pluginName).removeData('value');
        }

        _this.$element.prop('tabindex', _this.originalTabindex).off(eventNamespaceSuffix).off(_this.eventTriggers).unwrap().unwrap();

        _this.state.enabled = false;
      }
    }
  };

  // A really lightweight plugin wrapper around the constructor,
  // preventing against multiple instantiations
  $.fn[pluginName] = function(args) {
    return this.each(function() {
      var data = $.data(this, pluginName);

      if (data && !data.disableOnMobile) {
        (typeof args === 'string' && data[args]) ? data[args](): data.init(args);
      } else {
        $.data(this, pluginName, new Selectric(this, args));
      }
    });
  };

  /**
   * Default plugin options
   *
   * @type {object}
   */
  $.fn[pluginName].defaults = {
    onChange: function(elm) { $(elm).change(); },
    maxHeight: 300,
    keySearchTimeout: 500,
    arrowButtonMarkup: '<b class="button">&#x25be;</b>',
    disableOnMobile: false,
    nativeOnMobile: true,
    openOnFocus: true,
    openOnHover: false,
    hoverIntentTimeout: 500,
    expandToItemText: false,
    responsive: false,
    preventWindowScroll: true,
    inheritOriginalWidth: false,
    allowWrap: true,
    stopPropagation: true,
    optionsItemBuilder: '{text}', // function(itemData, element, index)
    labelBuilder: '{text}', // function(currItem)
    listBuilder: false, // function(items)
    keys: {
      previous: [37, 38], // Left / Up
      next: [39, 40], // Right / Down
      select: [9, 13, 27], // Tab / Enter / Escape
      open: [13, 32, 37, 38, 39, 40], // Enter / Space / Left / Up / Right / Down
      close: [9, 27] // Tab / Escape
    },
    customClass: {
      prefix: pluginName,
      camelCase: false
    },
    multiple: {
      separator: ', ',
      keepMenuOpen: true,
      maxLabelEntries: false
    },
    direction: 'auto', // auto | top | down
  };
}));
// Theme functions
window.theme = window.theme || {};
window.theme.version = "1.1.8"

theme.cacheSelectors = function () {
  theme.cache = {
    // General
    $window : $(window),
    $html : $('html'),
    $body : $(document.body),
    $recoverPasswordForm: $('#RecoverPasswordForm'),
    $customerLoginForm: $('#CustomerLoginForm'),
    $recoverPasswordLink: $('#RecoverPassword'),
    $hideRecoverPasswordLink: $('#HideRecoverPasswordLink'),
    $passwordResetSuccess: $('#ResetSuccess')
  };

  theme.mobileBreakpoint = 1024;

  theme.isMobile = function() {
    return theme.cache.$body.width() < this.mobileBreakpoint;
  };

  theme.isDesktop = function() {
    return theme.cache.$body.width() >= this.mobileBreakpoint;
  };

  theme.smoothScroll = function($el, speed, offset) {
    if (!speed)  { speed = 1000; }
    if (!offset) { offset = 0; }
    $('html, body').animate({
      scrollTop: $el.offset().top + offset
    }, speed);
  };
};

theme.sliders = {};
theme.debug = {};

theme.getHash = function () {
  return window.location.hash;
};

/**
 * Currency Helpers
 * -----------------------------------------------------------------------------
 * A collection of useful functions that help with currency formatting
 *
 * Current contents
 * - formatMoney - Takes an amount in cents and returns it as a formatted dollar value.
 *
 * Alternatives
 * - Accounting.js - http://openexchangerates.github.io/accounting.js/
 *
 */

theme.Currency = (function() {
  var moneyFormat = '${{amount}}'; // eslint-disable-line camelcase

  function formatMoney(cents, format) {
    if (typeof cents === 'string') {
      cents = cents.replace('.', '');
    }
    var value = '';
    var placeholderRegex = /\{\{\s*(\w+)\s*\}\}/;
    var formatString = (format || moneyFormat);

    function formatWithDelimiters(number, precision, thousands, decimal) {
      precision = precision || 2;
      thousands = thousands || ',';
      decimal = decimal || '.';

      if (isNaN(number) || number == null) {
        return 0;
      }

      number = (number / 100.0).toFixed(precision);

      var parts = number.split('.');
      var dollarsAmount = parts[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1' + thousands);
      var centsAmount = parts[1] ? (decimal + parts[1]) : '';

      return dollarsAmount + centsAmount;
    }

    switch (formatString.match(placeholderRegex)[1]) {
      case 'amount':
        value = formatWithDelimiters(cents, 2);
        break;
      case 'amount_no_decimals':
        value = formatWithDelimiters(cents, 0);
        break;
      case 'amount_with_comma_separator':
        value = formatWithDelimiters(cents, 2, '.', ',');
        break;
      case 'amount_no_decimals_with_comma_separator':
        value = formatWithDelimiters(cents, 0, '.', ',');
        break;
      case 'amount_no_decimals_with_space_separator':
        value = formatWithDelimiters(cents, 0, ' ');
        break;
    }

    return formatString.replace(placeholderRegex, value);
  }

  return {
    formatMoney: formatMoney
  }
})();

// Registering sections allows to create hooks for user actions in theme editor

theme.Sections = function Sections() {
  this.constructors = {};
  this.instances = [];

  $(document)
    .on('shopify:section:load', this._onSectionLoad.bind(this))
    .on('shopify:section:unload', this._onSectionUnload.bind(this))
    .on('shopify:section:select', this._onSelect.bind(this))
    .on('shopify:section:deselect', this._onDeselect.bind(this))
    .on('shopify:block:select', this._onBlockSelect.bind(this))
    .on('shopify:block:deselect', this._onBlockDeselect.bind(this));
};

theme.Sections.prototype = _.extend({}, theme.Sections.prototype, {
  _createInstance: function(container, constructor) {
    var $container = $(container);
    var id = $container.attr('data-section-id');
    var type = $container.attr('data-section-type');

    constructor = constructor || this.constructors[type];

    if (_.isUndefined(constructor)) {
      return;
    }

    var instance = _.extend(new constructor(container), {
      id: id,
      type: type,
      container: container
    });

    this.instances.push(instance);

    if (_.isFunction(instance.onLoad)) {
      instance.onLoad();
    }
  },

  _onSectionLoad: function(evt) {
    var container = $('[data-section-id]', evt.target)[0];
    if (container) {
      this._createInstance(container);
    }
  },

  _onSectionUnload: function(evt) {
    this.instances = _.filter(this.instances, function(instance) {
      var isEventInstance = (instance.id === evt.detail.sectionId);

      if (isEventInstance) {
        if (_.isFunction(instance.onUnload)) {
          instance.onUnload(evt);
        }
      }

      return !isEventInstance;
    });
  },

  _onSelect: function(evt) {
    // eslint-disable-next-line no-shadow
    var instance = _.find(this.instances, function(instance) {
      return instance.id === evt.detail.sectionId;
    });

    if (!_.isUndefined(instance) && _.isFunction(instance.onSelect)) {
      instance.onSelect(evt);
    }
  },

  _onDeselect: function(evt) {
    // eslint-disable-next-line no-shadow
    var instance = _.find(this.instances, function(instance) {
      return instance.id === evt.detail.sectionId;
    });

    if (!_.isUndefined(instance) && _.isFunction(instance.onDeselect)) {
      instance.onDeselect(evt);
    }
  },

  _onBlockSelect: function(evt) {
    // eslint-disable-next-line no-shadow
    var instance = _.find(this.instances, function(instance) {
      return instance.id === evt.detail.sectionId;
    });

    if (!_.isUndefined(instance) && _.isFunction(instance.onBlockSelect)) {
      instance.onBlockSelect(evt);
    }
  },

  _onBlockDeselect: function(evt) {
    // eslint-disable-next-line no-shadow
    var instance = _.find(this.instances, function(instance) {
      return instance.id === evt.detail.sectionId;
    });

    if (!_.isUndefined(instance) && _.isFunction(instance.onBlockDeselect)) {
      instance.onBlockDeselect(evt);
    }
  },

  register: function(type, constructor) {
    this.constructors[type] = constructor;

    $('[data-section-type=' + type + ']').each(function(index, container) {
      this._createInstance(container, constructor);
    }.bind(this));
  }
});

/**
 * Variant Selection scripts
 * ------------------------------------------------------------------------------
 *
 * Handles change events from the variant inputs in any `cart/add` forms that may
 * exist.  Also updates the master select and triggers updates when the variants
 * price or image changes.
 *
 * @namespace variants
 */

theme.Variants = (function() {

  /**
   * Variant constructor
   *
   * @param {object} options - Settings from `product.js`
   */
  function Variants(options) {
    this.$container = options.$container;
    this.product = options.product;
    this.singleOptionSelector = options.singleOptionSelector;
    this.originalSelectorId = options.originalSelectorId;
    this.enableHistoryState = options.enableHistoryState;
    this.currentVariant = this._getVariantFromOptions();

    $(this.singleOptionSelector, this.$container).on('change', this._onSelectChange.bind(this));
  }

  Variants.prototype = _.extend({}, Variants.prototype, {

    /**
     * Get the currently selected options from add-to-cart form. Works with all
     * form input elements.
     *
     * @return {array} options - Values of currently selected variants
     */
    _getCurrentOptions: function() {
      // get only visible options because there might be duplicated controls
      // for different screen resolutions
      var onlyVisibleOptions = this.singleOptionSelector + ':visible';
      var currentOptions = _.map($(onlyVisibleOptions, this.$container), function(element) {
        var $element = $(element);
        var type = $element.attr('type');
        var currentOption = {};

        if (type === 'radio' || type === 'checkbox') {
          if ($element[0].checked) {
            currentOption.value = $element.val();
            currentOption.index = $element.data('index');

            return currentOption;
          } else {
            return false;
          }
        } else {
          currentOption.value = $element.val();
          currentOption.index = $element.data('index');

          return currentOption;
        }
      });

      // remove any unchecked input values if using radio buttons or checkboxes
      currentOptions = _.compact(currentOptions);

      return currentOptions;
    },

    /**
     * Find variant based on selected values.
     *
     * @param  {array} selectedValues - Values of variant inputs
     * @return {object || undefined} found - Variant object from product.variants
     */
    _getVariantFromOptions: function() {
      var selectedValues = this._getCurrentOptions();
      var variants = this.product.variants;

      var found = _.find(variants, function(variant) {
        return selectedValues.every(function(values) {
          return _.isEqual(variant[values.index], values.value);
        });
      });

      return found;
    },

    /**
     * Event handler for when a variant input changes.
     */
    _onSelectChange: function() {
      var variant = this._getVariantFromOptions();

      this.$container.trigger({
        type: 'variantChange',
        variant: variant
      });

      if (!variant) {
        return;
      }

      this._updateMasterSelect(variant);
      this._updateImages(variant);
      this._updatePrice(variant);
      this._updateSKU(variant);
      this.currentVariant = variant;

      if (this.enableHistoryState) {
        this._updateHistoryState(variant);
      }
    },

    /**
     * Trigger event when variant image changes
     *
     * @param  {object} variant - Currently selected variant
     * @return {event}  variantImageChange
     */
    _updateImages: function(variant) {
      var variantImage = variant.featured_image || {};
      var currentVariantImage = this.currentVariant.featured_image || {};

      if (!variant.featured_image || variantImage.src === currentVariantImage.src) {
        return;
      }

      this.$container.trigger({
        type: 'variantImageChange',
        variant: variant
      });
    },

    /**
     * Trigger event when variant price changes.
     *
     * @param  {object} variant - Currently selected variant
     * @return {event} variantPriceChange
     */
    _updatePrice: function(variant) {
      if (variant.price === this.currentVariant.price && variant.compare_at_price === this.currentVariant.compare_at_price) {
        return;
      }

      this.$container.trigger({
        type: 'variantPriceChange',
        variant: variant
      });
    },

    /**
     * Trigger event when variant sku changes.
     *
     * @param  {object} variant - Currently selected variant
     * @return {event} variantSKUChange
     */
    _updateSKU: function(variant) {
      if (variant.sku === this.currentVariant.sku) {
        return;
      }

      this.$container.trigger({
        type: 'variantSKUChange',
        variant: variant
      });
    },

    /**
     * Update history state for product deeplinking
     *
     * @param  {variant} variant - Currently selected variant
     * @return {k}         [description]
     */
    _updateHistoryState: function(variant) {
      if (!history.replaceState || !variant) {
        return;
      }

      var newurl = window.location.protocol + '//' + window.location.host + window.location.pathname + '?variant=' + variant.id;
      window.history.replaceState({path: newurl}, '', newurl);
    },

    /**
     * Update hidden master select of variant change
     *
     * @param  {variant} variant - Currently selected variant
     */
    _updateMasterSelect: function(variant) {
      $(this.originalSelectorId, this.$container).val(variant.id);
    }
  });

  return Variants;
})();

/*******************************************************************************
    Customers
  *****************************************************************************/

theme.loginForms = function() {
  function showRecoverPasswordForm() {
    theme.cache.$recoverPasswordForm.show();
    theme.cache.$customerLoginForm.hide();
  }

  function hideRecoverPasswordForm() {
    theme.cache.$recoverPasswordForm.hide();
    theme.cache.$customerLoginForm.show();
  }

  theme.cache.$recoverPasswordLink.on('click', function(evt) {
    evt.preventDefault();
    showRecoverPasswordForm();
  });

  theme.cache.$hideRecoverPasswordLink.on('click', function(evt) {
    evt.preventDefault();
    hideRecoverPasswordForm();
  });

  // Allow deep linking to recover password form
  if (theme.getHash() == '#recover') {
    showRecoverPasswordForm();
  }
};

theme.resetPasswordSuccess = function() {
  theme.cache.$passwordResetSuccess.show();
};
theme.setupMap = function($scope) {
  // Disable scroll zooming and bind back the click event
  function onMapMouseleaveHandler(event) {
    var that = $(this);

    that.on('click', onMapClickHandler);
    that.off('mouseleave', onMapMouseleaveHandler);
    that.find('iframe').css("pointer-events", "none");
  }

  function onMapClickHandler(event) {
    var that = $(this);

    // Disable the click handler until the user leaves the map area
    that.off('click', onMapClickHandler);

    // Enable scrolling zoom
    that.find('iframe').css("pointer-events", "auto");

    // Handle the mouse leave event
    that.on('mouseleave', onMapMouseleaveHandler);
  }

  // Enable map zooming with mouse scroll when the user clicks the map
  $scope.find('.map .map__wrapper').on('click', onMapClickHandler);
};



/*******************************************************************************
 Cookie Manager
 *****************************************************************************/
theme.CookieManager = (function () {
    var CookieManager = function () {};
    CookieManager.prototype.set = function (cname, cvalue, exdays) {
        var d = new Date();
        d.setTime(d.getTime() + (exdays*24*60*60*1000));
        var expires = "expires="+ d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    };

    CookieManager.prototype.get = function (cname) {
        var name = cname + "=";
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for(var i = 0; i <ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    };

    // When the cart content is already loaded
    CookieManager.prototype.check = function (cname) {
        var cname_ = this.get(cname);
        if(cname_ != "" && cname_ != null) {
            return true;
        } else {
            return false;
        }
    }

    CookieManager.prototype.remove = function (cname) {
        var d = new Date();
        d.setTime(d.getTime() + (-1000*24*60*60*1000));
        var expires = "expires="+ d.toUTCString();
        document.cookie = cname + "=" + 'deleted' + ";" + expires + ";path=/";
    };

    return CookieManager;
})();

/*******************************************************************************
    Product card
  *****************************************************************************/
theme.productCardsInit = function ($scope) {

  var selectors = {
    variantSelector: '.product-form__variants',
    form: '.product-form',
  };

  $scope.find('.product-card ' + selectors.variantSelector).on('change', function(e) {
    var $card = $(this).parents('.product-card').first();
    $card.find(selectors.form).trigger('submit');
    // Return select back
    setTimeout(function() {
      var $selector = $card.find(selectors.variantSelector);
      if ($selector.hasClass('product-form__variants--has-variants')) {
        $selector.prop('selectedIndex', 0).selectric('refresh');
      }
    }, 500);
  });

  $scope.find('.product-card--hoverable ' + selectors.variantSelector + ':not(.hide)').selectric({
    maxHeight: 145,
    openOnHover: true,
    direction: 'bottom',
    hoverIntentTimeout: 200
  });

  $scope.find('.product-card--no-hover ' + selectors.variantSelector + ':not(.hide)').selectric({
    maxHeight: 210,
    openOnHover: false,
    direction: 'top'
  });
};

/*============================================================================
  Drawer modules
  - Docs http://shopify.github.io/Timber/#drawers
==============================================================================*/
theme.Drawers = (function () {
  var Drawer = function (id, position, options) {
    var defaults = {
      close: '.js-drawer-close',
      open: '.js-drawer-open-' + position,
      openClass: 'js-drawer-open',
      dirOpenClass: 'js-drawer-open-' + position
    };

    this.mobileBreakpoint = 1024;

    this.$nodes = {
      parent: $('body, html'),
      page: $('#page_container'),
      moved: $('.is-moved-by-drawer')
    };

    this.config = $.extend(defaults, options);
    this.position = position;

    this.$drawer = $('#' + id);

    if (!this.$drawer.length) {
      return false;
    }

    this.drawerIsOpen = false;
    this.init();
  };

  Drawer.prototype.init = function () {
    $(this.config.open).on('click', $.proxy(this.open, this));
    this.$drawer.find(this.config.close).on('click', $.proxy(this.close, this));
    // public API for closing the drawer
    var _self = this;
    theme.closeCartDrawer = function() {
      _self.close();
    };
  };

  Drawer.prototype.open = function (evt) {
    // Keep track if drawer was opened from a click, or called by another function
    var externalCall = false;

    // If drawer disabled for mobile, just go to cart page
    if ('{{ settings.ajax_cart_method }}' == 'page') { //  && theme.cache.$body.width() < this.mobileBreakpoint
      return true;
    }

    // Prevent following href if link is clicked
    if (evt) {
      evt.preventDefault();
    } else {
      externalCall = true;
    }

    // Without this, the drawer opens, the click event bubbles up to $nodes.page
    // which closes the drawer.
    if (evt && evt.stopPropagation) {
      evt.stopPropagation();
      // save the source of the click, we'll focus to this on close
      this.$activeSource = $(evt.currentTarget);
    }

    if (this.drawerIsOpen && !externalCall) {
      return this.close();
    }

    // Notify the drawer is going to open
    theme.cache.$body.trigger('beforeDrawerOpen.theme', this);

    // Add is-transitioning class to moved elements on open so drawer can have
    // transition for close animation
    this.$nodes.moved.addClass('is-transitioning');
    this.$drawer.prepareTransition();

    this.$nodes.parent.addClass(this.config.openClass + ' ' + this.config.dirOpenClass);
    this.drawerIsOpen = true;

    // Set focus on drawer
    if (theme.cache.$body.width() < this.mobileBreakpoint) {
      this.trapFocus(this.$drawer, 'drawer_focus');
    }

    // Run function when draw opens if set
    if (this.config.onDrawerOpen && typeof(this.config.onDrawerOpen) == 'function') {
      if (!externalCall) {
        this.config.onDrawerOpen();
      }
    }

    if (this.$activeSource && this.$activeSource.attr('aria-expanded')) {
      this.$activeSource.attr('aria-expanded', 'true');
    }

    // Lock scrolling on mobile
    this.$nodes.page.on('touchmove.drawer', function () {
      return false;
    });

    this.$nodes.page.on('click.drawer', $.proxy(function () {
      this.close();
      return false;
    }, this));

    // Notify the drawer has opened
    theme.cache.$body.trigger('afterDrawerOpen.theme', this);
  };

  Drawer.prototype.close = function () {
    if (!this.drawerIsOpen) { // don't close a closed drawer
      return;
    }

    // Notify the drawer is going to close
    theme.cache.$body.trigger('beforeDrawerClose.theme', this);

    // deselect any focused form elements
    $(document.activeElement).trigger('blur');

    // Ensure closing transition is applied to moved elements, like the nav
    this.$nodes.moved.prepareTransition({ disableExisting: true });
    this.$drawer.prepareTransition({ disableExisting: true });

    this.$nodes.parent.removeClass(this.config.dirOpenClass + ' ' + this.config.openClass);

    this.drawerIsOpen = false;

    // Remove focus on drawer
    this.removeTrapFocus(this.$drawer, 'drawer_focus');

    this.$nodes.page.off('.drawer');

    // Notify the drawer is closed now
    theme.cache.$body.trigger('afterDrawerClose.theme', this);
  };

  Drawer.prototype.trapFocus = function ($container, eventNamespace) {
    var eventName = eventNamespace ? 'focusin.' + eventNamespace : 'focusin';

    $container.attr('tabindex', '-1');

    $container.focus();

    $(document).on(eventName, function (evt) {
      if ($container[0] !== evt.target && !$container.has(evt.target).length) {
        $container.focus();
      }
    });
  };

  Drawer.prototype.removeTrapFocus = function ($container, eventNamespace) {
    var eventName = eventNamespace ? 'focusin.' + eventNamespace : 'focusin';

    $container.removeAttr('tabindex');
    $(document).off(eventName);
  };

  return Drawer;
})();

theme.drawersInit = function () {
  theme.DesktopLeftDrawer = new theme.Drawers('DesktopNavDrawer', 'desktop-left');
  theme.LeftDrawer = new theme.Drawers('NavDrawer', 'left');
  theme.RightDrawer = new theme.Drawers('CartDrawer', 'right', {
    'onDrawerOpen': ajaxCart.load
  });
  theme.cache.$body.on('beforeDrawerOpen.theme', function() {
    if (theme.LeftDrawer.drawerIsOpen) {
      theme.LeftDrawer.close();
    } else if(theme.RightDrawer.drawerIsOpen) {
      theme.RightDrawer.close();
    } else if(theme.DesktopLeftDrawer.drawerIsOpen) {
      theme.DesktopLeftDrawer.close();
    }
  });
};

theme.Modal = (function () {
  var Modal = function (elementID) {
    var defaults = this.config = {
      open: '.js-modal-open',
      close: '.js-modal-close',
    };

    this.ID = elementID;
    this.$modal = $('#' + this.ID);

    this.modalIsOpen = false;
    this.init();
  };

  Modal.prototype.init = function () {
    var _self = this;
    $(document).on("click.show-" + this.ID, this.config.open+'-'+this.ID, $.proxy(this.show, this));
    $(document).on("click.hide-" + this.ID, this.config.close, $.proxy(this.hide, this));
    // Close when clicked outside
    $(document).on("click.close-" + this.ID, function(event) {
      if (event.target == _self.$modal[0]) {
        _self.hide();
      }
    });
  };

  Modal.prototype.show = function (evt) {
    // Prevent following href if link is clicked
    if (evt) {
      evt.preventDefault();
    } else {
      externalCall = true;
    }

    this.$modal.css({display: "block"});
    this.modalIsOpen = true;
    ajaxCart.load();
  };

  // When the cart content is already loaded
  Modal.prototype.onlyShow = function (evt) {
    this.$modal.css({display: "block"});
    this.modalIsOpen = true;
  }

  Modal.prototype.hide = function (evt) {
    this.$modal.css({display: "none"});
    this.modalIsOpen = false;
  };

  return Modal;
})();

theme.modalInit = function () {
  if ($('#CartModal').length > 0) {
    theme.cartModal = new theme.Modal('CartModal');
  }
  if ($('#SplashModal').length > 0) {
    theme.SplashModalEl = new theme.Modal('SplashModal');

  }
};

/*******************************************************************************
 Top Bar
 *****************************************************************************/
theme.splashModals = function() {
    var selector = {
        modal: '#SplashModal'
    }
    var daysHidden = $(selector.modal).data('days-hidden'),
        showUpDelay = ($(selector.modal).data('showup-delay') * 1000), //to milliseconds
        testMode = $(selector.modal).data('test-mode'),
        modalContent = $(selector.modal).find('.modal-content'),
        explosiveOffer = modalContent.data('explosive-offer'),
        explosionGif = modalContent.data('explosion-gif');

    var cookieName = 'konversion-modals';
    var cookie = new theme.CookieManager();

    if(cookie.check(cookieName)){ 
        if(cookie.get(cookieName) == 'open'){
            cookie.set(cookieName, 'closed', daysHidden);
            showModal();
        }
    }else{
        cookie.set(cookieName, 'open', daysHidden);
        showModal();
    }

    //test mode
    if (theme.adminSet && testMode) {
        showModal();
    }

    function showModal() {
        setTimeout(function () {
            theme.SplashModalEl.onlyShow();
            if(explosiveOffer){
                modalContent.css("transform", "scale(0)");
                $(selector.modal)
                    .css("background-image", "url("+explosionGif+")")
                    .css("background-size", "cover")
                    .css("background-repeat", "no-repeat")
                    .css("background-position", "50% 50%");

                setTimeout(function () {
                    modalContent.css("transform", "scale(1)");
                    setTimeout(function () {
                        $(selector.modal).css("background", "rgba(0, 0, 0, 0.4)");
                    }, 1000);
                }, 1500);
            }
        }, showUpDelay);
    }
};
theme.Swatches = (function () {
  var Swatches = function (el) {
    this.$swatch = $(el);
    this.$form = this.$swatch.parents('form').first();
    this.$swatch.find('input').change($.proxy(this.onChange, this));
  };

  Swatches.prototype.onChange = function (e) {
    var $input = $(e.target);
    var optionIndex = this.$swatch.data('index');
    var optionValue = $input.val();
    this.$form.find('.product-options__selector[data-index="option' + optionIndex + '"]')
              .val(optionValue)
              .trigger('change');
    // Highlight
    this.$swatch.find('.swatches__option').removeClass('swatches__option--selected');
    $input.parents('.swatches__option').first().addClass('swatches__option--selected');
  };

  return Swatches;
})();

theme.initSwatches = function () {
  $('.swatches').each(function(idx, el) {
    new theme.Swatches(el);
  });
  $('[data-color-tooltip!=""]').qtip({
    content: {attr: 'data-color-tooltip'},
    style: {classes: 'qtip-light qtip-shadow'}
  });

};

/*******************************************************************************
    Mobile nav
  *****************************************************************************/
theme.mobileNavInit = function() {
  $(".mobileMenu").mmenu({
    offCanvas: false
  });
};

/*******************************************************************************
    Header section
  *****************************************************************************/
;( function( window ) {
	
	'use strict';

	var document = window.document;

	function extend( a, b ) {
		for( var key in b ) { 
			if( b.hasOwnProperty( key ) ) {
				a[key] = b[key];
			}
		}
		return a;
	}

	function cbpHorizontalSlideOutMenu( el, options ) {	
		this.el = el;
		this.options = extend( this.defaults, options );
		this._init();
	}

	cbpHorizontalSlideOutMenu.prototype = {
		defaults : {},
		_init : function() {
			this.current = -1;
			this.touch = Modernizr.touch;
			this.menu = this.el.querySelector( '.cbp-hsmenu' );
			this.menuItems = this.el.querySelectorAll( '.cbp-hsmenu > li' );
			this.menuBg = document.createElement( 'div' );
			this.menuBg.className = 'cbp-hsmenubg';
			this.el.appendChild( this.menuBg );
			this._initEvents();
		},
		_openMenu : function( el, ev ) {

			var self = this,
				item = el.parentNode,
				items = Array.prototype.slice.call( this.menuItems ),
				submenu = item.querySelector( '.cbp-hssubmenu' ),
				closeCurrent = function( current ) {
					var current = current || self.menuItems[ self.current ];
					current.className = '';
					current.setAttribute( 'data-open', '' );	
				},
				closePanel = function() {
					self.current = -1;
					self.menuBg.style.height = '0px';
				};

			//workaround to center the product menu
			var offsetLeft = $(submenu).offset().left;
			$(submenu).css('margin-left', -offsetLeft);

			if( submenu ) {

				ev.preventDefault();

				if( item.getAttribute( 'data-open' ) === 'open' ) {
					closeCurrent( item );
					closePanel();
				}
				else {
					item.setAttribute( 'data-open', 'open' );
					if( self.current !== -1 ) {
						closeCurrent();
					}
					self.current = items.indexOf( item );
					item.className = 'cbp-hsitem-open';
					self.menuBg.style.height = submenu.offsetHeight + 'px';
				}
			}
			else {
				if( self.current !== -1 ) {
					closeCurrent();
					closePanel();
				}
			}

		},
		_initEvents : function() {
			
			var self = this;

			Array.prototype.slice.call( this.menuItems ).forEach( function( el, i ) {
				var trigger = el.querySelector( 'a' );
				if( self.touch ) {
					trigger.addEventListener( 'touchstart', function( ev ) { self._openMenu( this, ev ); } );
				}
				else {
					trigger.addEventListener( 'click', function( ev ) { self._openMenu( this, ev ); } );	
				}
			} );
			
			window.addEventListener( 'resize', function( ev ) { self._resizeHandler(); } );

		},
		_resizeHandler : function() {
			var self = this;
			function delayed() {
				self._resize();
				self._resizeTimeout = null;
			}

			if ( this._resizeTimeout ) {
				clearTimeout( this._resizeTimeout );
			}

			this._resizeTimeout = setTimeout( delayed, 50 );
		},
		_resize : function() {
			if( this.current !== -1 ) {
				this.menuBg.style.height = this.menuItems[ this.current ].querySelector( '.cbp-hssubmenu' ).offsetHeight + 'px';
			}
		}
	}

	window.cbpHorizontalSlideOutMenu = cbpHorizontalSlideOutMenu;

} )( window );
theme.HeaderSection = (function() {
  function HeaderSection(container) {
    var $container;
    var menu_type;
    this.$container = $container = this.$container = $(container);
    menu_type = $container.data("menu-type");
    if(menu_type == "text-menu") {
      $container.find('ul.sf-menu').superfish({
        delay: 500,
        speed: 200,
      });
    } else {
		  var menu = new cbpHorizontalSlideOutMenu( document.getElementById( 'cbp-hsmenu-wrapper' ) );
    }
    $container.find('.js-expand-search').on('click', this._toggleSearchField.bind(this));
    var _self = this;
    $container.find('.header-search').on('keyup', function(e) {
      if (e.key === "Escape") {
        _self._toggleSearchField();
      }
    });
  }

  HeaderSection.prototype = _.extend({}, HeaderSection.prototype, {

	_toggleSearchField: function() {
		$search = this.$container.find(".header-search");
		if ($search.hasClass('header-search--active')) {
			$search.removeClass('header-search--active');
		} else {
			$search.addClass('header-search--active');
			$search.find('input').focus();
		}
	},

	onUnload: function() {
		this.cleanUp();
	},

	cleanUp: function() {}

  });

  return HeaderSection;
})();
/*******************************************************************************
    Slideshow section
  *****************************************************************************/

theme.Slideshow = (function() {
  this.$slideshow = null;
  var classes = {
    wrapper: 'slideshow-wrapper',
    slideshow: 'slideshow',
    currentSlide: 'slick-current'
  };

  function slideshow(el) {
    this.$slideshow = $(el);
    this.$wrapper = this.$slideshow.closest('.' + classes.wrapper);
    this.$pause = this.$wrapper.find('.' + classes.pauseButton);

    this.settings = {
      accessibility: true,
      arrows: false,
      dots: true,
      fade: true,
      draggable: true,
      touchThreshold: 20,
      autoplay: this.$slideshow.data('autoplay'),
      autoplaySpeed: this.$slideshow.data('speed')
    };

    this.$slideshow.slick(this.settings);
  }

  return slideshow;
})();

theme.slideshows = {};

theme.SlideshowSection = (function() {
  function SlideshowSection(container) {
    var $container = this.$container = $(container);
    var sectionId = $container.attr('data-section-id');
    var slideshow = this.slideshow = '#slideshow_' + sectionId;
    theme.slideshows[slideshow] = new theme.Slideshow(slideshow);
  }

  return SlideshowSection;
})();

theme.SlideshowSection.prototype = _.extend({}, theme.SlideshowSection.prototype, {
  onUnload: function() {
    delete theme.slideshows[this.slideshow];
  },

  onBlockSelect: function(evt) {
    var $slideshow = $(this.slideshow);

    // Ignore the cloned version
    var $slide = $('.slideshow__slide--' + evt.detail.blockId + ':not(.slick-cloned)');
    var slideIndex = $slide.data('slick-index');

    // Go to selected slide, pause autoplay
    $slideshow.slick('slickGoTo', slideIndex).slick('slickPause');
  },

  onBlockDeselect: function() {
    // Resume autoplay
    $(this.slideshow).slick('slickPlay');
  }
});



/*******************************************************************************
    Slider section
  *****************************************************************************/

theme.Slider = (function() {
  this.$slider = null;
  var classes = {
    wrapper: 'slider-wrapper',
    slider: 'slider',
    currentSlide: 'slick-current'
  };

  function slider(el, $container) {
    this.$slider = $(el);
    this.$wrapper = this.$slider.closest('.' + classes.wrapper);
    this.$pause = this.$wrapper.find('.' + classes.pauseButton);

    var fullWidth = this.$slider.data('content-slider');

    this.settings = {
      dots: !!this.$slider.data('slider-dots'),
      fade: this.$slider.data('slider-effect') == 'fade',
      speed: 500,
      infinite: true,
      speed: 300,
      slidesToShow: fullWidth ? 1 : 4,
      slidesToScroll: fullWidth ? 1 : 4,
      responsive: [
        {
          breakpoint: 768,
          settings: {
            slidesToShow: fullWidth ? 1 : 3,
            slidesToScroll: fullWidth ? 1 : 3
          }
        },
        {
          breakpoint: 480,
          settings: {
            slidesToShow: fullWidth ? 1 : 2,
            slidesToScroll: fullWidth ? 1 : 2
          }
        }
      ]
    };

    this.$slider.slick(this.settings);
    theme.productCardsInit(this.$wrapper);

    // When there are less than 4 items in featured products section
    // we display simple grid. Inititalize product cards for it too:
    var $productGrid = $container.find('.no-slider--grid');
    if ($productGrid.length > 0) {
      theme.productCardsInit($productGrid);
    }
  }

  return slider;
})();

theme.sliders = {};

theme.SliderSection = (function() {
  function SliderSection(container) {
    var $container = this.$container = $(container);
    var sectionId = $container.attr('data-section-id');
    var slider = this.slider = '#slider_' + sectionId;
    theme.sliders[slider] = new theme.Slider(slider, $container);
  }

  return SliderSection;
})();

theme.SliderSection.prototype = _.extend({}, theme.SliderSection.prototype, {
  onUnload: function() {
    delete theme.sliders[this.slider];
  },

  onBlockSelect: function(evt) {
    var $slider = $(this.slider);

    // Ignore the cloned version
    var $slide = $('.slider__slide--' + evt.detail.blockId + ':not(.slick-cloned)');
    var slideIndex = $slide.data('slick-index');

    // Go to selected slide, pause autoplay
    $slider.slick('slickGoTo', slideIndex).slick('slickPause');
  },

  onBlockDeselect: function() {
    // Resume autoplay
    $(this.slider).slick('slickPlay');
  }
});

/*******************************************************************************
    Product page section
  *****************************************************************************/

theme.ProductImagesSlider = (function() {
  this.$sliderThumbs = null;
  this.$sliderImage = null;

  var classes = {
    thumbs: 'js-product-thumbs',
    image: 'js-product-image'
  };

  function productImagesSlider(el) {
    $wrapper = $(el);
    if ($wrapper.hasClass('product-images--single')) {
      return false;
    }

    var sliderId = $wrapper.attr('id');
    this.$sliderThumbs = $wrapper.find('.' + classes.thumbs);
    this.$sliderImage = $wrapper.find('.' + classes.image);
    this.thumbsSettings = {
      slidesToShow: 4,
      slidesToScroll: 1,
      asNavFor: '#' + sliderId + ' .' + classes.image,
      dots: false,
      arrows: this.$sliderThumbs.data('arrows'),
      centerMode: false,
      focusOnSelect: true,
      vertical: this.$sliderThumbs.data('vertical'),
      verticalSwiping: true
    };
    this.imageSettings = {
      slidesToShow: 1,
      slidesToScroll: 1,
      arrows: this.$sliderImage.data('arrows'),
      dots: false,
      fade: true,
      asNavFor: '#' + sliderId + ' .' + classes.thumbs,
      swipe: false,
      swipeToSlide: false,
    };

    var imageHeight = this.$sliderImage.height();
    //this.$sliderThumbs.css({'max-height': imageHeight + 'px'});
    this.$sliderThumbs.slick(this.thumbsSettings);
    this.$sliderImage.slick(this.imageSettings);
  }

  return productImagesSlider;
})();

theme.RelatedProductsSlider = (function() {
  this.$relSlider = null;
  var classes = {
    wrapper: 'slider-wrapper',
    slider: 'slider',
    currentSlide: 'slick-current'
  };

  function slider(el) {
    this.$relSlider = $(el);

    this.settings = {
      dots: false,
      fade: false,
      speed: 500,
      infinite: true,
      speed: 300,
      slidesToShow: 3,
      slidesToScroll: 3,
      responsive: [
        {
          breakpoint: 480,
          settings: {
            slidesToShow: 2,
            slidesToScroll: 2
          }
        }
      ]
    };

    this.$relSlider.slick(this.settings);
  }

  return slider;
})();

theme.ProductPageSection = (function() {

  function ProductPageSection(container) {
    var $container = this.$container = $(container);
    var sectionId = $container.attr('data-section-id');
    var _self = this;

    this.theProduct = JSON.parse(document.getElementById('ProductJson-' + sectionId).innerHTML);

    this.settings = {
      sectionId: sectionId,
      enableHistoryState: $container.data('enable-history-state') || false,
      mobileSize: 1024
    };

    this.selectors = {
      originalSelectorId: '#ProductSelect-' + sectionId,
      singleOptionSelector: '.product-options__selector-' + sectionId,
      addToCart: '#' + sectionId + ' .product-info .product-form-wrapper .product-form__cart-submit',
      addToCartText: '#' + sectionId + ' .product-info .product-form-wrapper .product-form__cart-submit-text',
      productPrices: '.product-info .product-price',
      originalPrice: '.product-info .product-price__price',
      comparePrice: '.product-info .product-price__old',
      discountPercent: '.product-info .product-price__percent',
      salePriceWrapper: '.product-info .product-price__sale',
      SKU: '.variant-sku',
      qty: '.variant-qty',
      inPageCartButton: '#' + sectionId + ' .product-form__cart',
      stickyBtnStart: '#' + sectionId + ' .js-sticky-btn-start',
      stickyCartButton: '#' + sectionId + ' .product-form__cart--sticky',
      stickyCartButtonText: '#' + sectionId + ' .product-form__cart--sticky button > span.btn-text',
      cartFormMobile: '#' + sectionId + ' .product-form--mobile',
      readMoreBtn: '.product-template .product-info__more',
      productDescription: '.product-template .product-info__description',
      productFullDescription: '.product-template .product-info__full_description',
      accordion: '#' + sectionId + ' .accordion',
      productInfo: '.product-info',
      productVariants: '.content-product-variants',
      productInfoDesktop: '.product-info-desktop',
      productInfoMobile: '.product-info-mobile',
      addToCartBar: '.product-add-to-cart-bar ',
      addToCartBarBtn: '.product-add-to-cart-bar .btn--add-to-cart',
      addToCartBarBtnText: '.product-add-to-cart-bar .btn--add-to-cart .product-form__cart-submit-text',
      addToCartBarPrice: '.product-add-to-cart-bar .product-price',
      countDownOffer: '.countdown-offer-clock'
    };

    // Thumbs & Slider
    var slider = this.slider = '#' + sectionId + '_images';
    theme.sliders[slider] = new theme.ProductImagesSlider(slider);

    var relSlider = this.relSlider = '#slider_related-products';
    theme.sliders[relSlider] = new theme.RelatedProductsSlider(relSlider);
    theme.productCardsInit($container);

    // Zoom image
    if (turnOnZoom == true) {
      $('.product-images--single .product-images__image, .product-images__image li').each(function(idx, el) {
        var $img = $(el).find('img');
        if(theme.isMobile()) {
          new PinchZoom($img[0], {});
        } else {
          $(el).zoom({ on: $img.data('zoom-type'), url: $img.data('original') });
        }
      });
    }

    $('#tab-container').easytabs();

    // Switch image when variant is changed
    this._initVariants();
    // Switch variant when image is changed
    if (theme.sliders[this.slider].$sliderImage) {
      var $imgSlider = theme.sliders[this.slider].$sliderImage;
      $imgSlider.on('beforeChange', this._matchVariantForCurrentSlide.bind(this));

      // Sometimes the first slide/image does not correspond to selected variant
      // if images was re-ordered. So make sure to adjust variant selectors to 0-position slide
      setTimeout(function(){
        _self._matchVariantForCurrentSlide(null, null, 1, 0);
      }, 500);
    }

    this._stickyCartBtn();
    this._removeReviewsDuplicate();
    theme.initSwatches();
    this._initAccordion();
    this._initCountDownOffer();
    this._productReviews();
    this._productInfiniteOptions();
    this._responsiveElements();
    // The following function requires page to be loaded,
    // because it calculates its height. So deleay it for 3 seconds
    setTimeout(function(){
      _self._readMore();
    }, 3000);
  }

  return ProductPageSection;
})();

theme.ProductPageSection.prototype = _.extend({}, theme.ProductPageSection.prototype, {

  onLoad: function() {
    if (_.isFunction(ajaxCart.qtySelectors)) {
      ajaxCart.qtySelectors();
    }
    this._initAddToCartStickyBar();
  },

  onUnload: function() {
    delete theme.sliders[this.slider];
    delete theme.sliders[this.relSlider];
    $(document).off('touchmove.track-add-to-cart-btn');
    $(document).off('scroll.track-add-to-cart-btn');
  },

  _stickyCartBtn: function() {
    if ($(this.selectors.stickyCartButton).length > 0) {
      if($('.product-template').data('lock-atc-btn') === true){
        var $stickyBtn = $(this.selectors.stickyCartButton);
        $stickyBtn.addClass('stuck');
      }else{
        //this._trackScrolling();
        $(document).on('scroll.track-add-to-cart-btn', this._trackScrolling.bind(this));
        $(document).on('touchmove.track-add-to-cart-btn', this._trackScrolling.bind(this));
      }
      $(this.selectors.stickyCartButton).on('click', this._submitCartForm.bind(this));
    }
  },

  _submitCartForm: function() {
    $(this.selectors.cartFormMobile).trigger('submit');
  },

  _trackScrolling: function() {
    // only for mobile
    if (theme.cache.$body.width() <= 767) {
      var $stickyBtn = $(this.selectors.stickyCartButton);
      var startPosition = $(this.selectors.stickyBtnStart).position();
      var distanceYBottom = window.pageYOffset + theme.cache.$window.height();
      var stickAt = distanceYBottom;

      if (startPosition.top <= stickAt) {
        $stickyBtn.addClass('stuck');
      } else {
        $stickyBtn.removeClass('stuck');
      }
    }
  },

  _initVariants: function() {
    var options = {
      $container: this.$container,
      enableHistoryState: this.$container.data('enable-history-state') || false,
      singleOptionSelector: this.selectors.singleOptionSelector,
      originalSelectorId: this.selectors.originalSelectorId,
      product: this.theProduct
    };

    this.variants = new theme.Variants(options);

    this.$container.on('variantChange', this._updateAddToCart.bind(this));
    this.$container.on('variantImageChange', this._switchImage.bind(this));
    this.$container.on('variantPriceChange', this._updatePrice.bind(this));
    this.$container.on('variantSKUChange', this._updateSKU.bind(this));
  },

  _updateAddToCart: function(evt) {
    var variant = evt.variant;
    var qty;
    var self = this;

    if (variant) {
      this.$container.find(this.selectors.productPrices).removeClass('visibility-hidden');

      //Update Add to cart bar
      $(this.selectors.addToCartBarPrice).removeClass('visibility-hidden').css('width', 'auto');

      if (variant.available) {
        updateATCButtons(false, backend.strings.addToCart)
      } else {
        updateATCButtons(true, backend.strings.soldOut)
      }

      // Update left in stock label
      if (variant.inventory_quantity > 0) {
        qty = variant.inventory_quantity;
      } else {
        if (variant.available) {
          qty = 1;
        } else {
          qty = 0;
        }
      }

      this.$container.find(this.selectors.qty).html(qty);

      // There are two separated variant selectors for mobile and desktop
      // So it needs to be updated manually
      $(this.selectors.originalSelectorId + '--desktop').val(variant.id)

    } else {
      // The variant doesn't exist
      updateATCButtons(true, backend.strings.unavailable)
      this.$container.find(this.selectors.productPrices).addClass('visibility-hidden');
      $(this.selectors.addToCartBarPrice).addClass('visibility-hidden').css('width', 0); //add to cart bar
      this.$container.find(this.selectors.qty).html('-');
    }
    /**
     * Update ALL Add to Cart buttons
     * @param disabled
     * @param text
     */
    function updateATCButtons(disabled, text) {
      $(self.selectors.addToCart).prop('disabled', disabled);
      $(self.selectors.addToCartText).text(text);

      // Update mobile sticky button
      $(self.selectors.stickyCartButton).find('button').prop('disabled', disabled);
      $(self.selectors.stickyCartButtonText).text(text);

      //Update Add to cart bar
      $(self.selectors.addToCartBarBtn).prop('disabled', disabled)
      $(self.selectors.addToCartBarBtnText).text(text);
    }


  },

  _switchImage: function(evt) {
    var variant = evt.variant;
    var $productImagesSlider = theme.sliders[this.slider];
    var slideIdx;
    if (variant.featured_image) {
      slideIdx = this._getSlideIndexForVariant($productImagesSlider, variant);
      if (slideIdx || slideIdx == 0) {
        $productImagesSlider.$sliderImage.slick('slickGoTo', slideIdx);
      }
    }
  },

  _matchVariantForCurrentSlide: function(event, slick, currentSlide, nextSlide) {
    var variant = this._getVariantBySlideIndex(nextSlide);

    if (!variant) { return false; }

    var variantSelector = $(this.selectors.originalSelectorId);
    var _self = this;
    if (variantSelector.val() != variant.id) {
      _.each(variant.options, function(opt, idx) {
        var optIdx = idx + 1;
        var optName = 'option-' + optIdx;
        // If swatches
        var $swatches = _self.$container.find('.swatches[data-index=' + optIdx + ']');
        if ($swatches.length > 0) {
          $swatches.find('input[name=' + optName + ']').each(function(idx, el) {
            if ($(el).val() == opt) {
              $(el).trigger('click');
              return true;
            }
          });
        } else {
          $dropdown = _self.$container.find('.product-options__selector[data-index=option' + optIdx + ']');
          $dropdown.val(opt).trigger('change');
          return true;
        }
      });
    }

  },

  _getSlideIndexForVariant: function($slider, variant) {
      var index;
      var $slides = $slider.$sliderThumbs.find('.slick-slide:not(.slick-cloned)');
      $slides.each(function(idx, slide){
        // find image position in slider
        if (!index && $(slide).find('img[data-id=' + variant.featured_image.id + ']').length > 0) {
          index = idx;
          return false;
        }
      });
      return index;
  },

  _getVariantBySlideIndex: function(index) {
    var $slider = theme.sliders[this.slider].$sliderThumbs;
    var slide = $slider.find('.slick-slide:not(.slick-cloned)')[index];
    var imageId, variant;
    if (slide) {
      imageId = $(slide).find('img:first').data('id');
      variant = _.find(this.theProduct.variants, function(variant){
        return variant.featured_image && variant.featured_image.id == imageId
      });
    }
    return variant;
  },

  _updatePrice: function(evt) {
    var variant = evt.variant;
    var variantPrice = theme.Currency.formatMoney(variant.price, backend.moneyFormat),
        $pricesRef,
        $inCurrency,
        compareAtPriceInCurrency;

    // Convert currency when price is changed after changing variant
    var isCurrencyEnabled = (new String("{{settings.show_multiple_currencies}}")) == "true";
    if (isCurrencyEnabled) {
      $pricesRef = this.$container.find(".product-variant-prices-ref");
      inCurrency = $pricesRef.find("[data-variant-id=" + variant.id + "]").html();
      if (inCurrency) {
        // price|compare_at_price
        inCurrencyParts = inCurrency.split("|");
        variantPrice = inCurrencyParts[0];
        compareAtPriceInCurrency = inCurrencyParts[1];
      }
    }

    // Update the product price
    this.$container.find(this.selectors.originalPrice).html(variantPrice);

    // Update and show the product's compare price if necessary
    if (variant.compare_at_price > variant.price) {
      var discountPercent = Math.round((variant.compare_at_price - variant.price) * 100 / variant.compare_at_price);
      if (!compareAtPriceInCurrency) {
        compareAtPriceInCurrency = theme.Currency.formatMoney(variant.compare_at_price, backend.moneyFormat);
      }
      this.$container.find(this.selectors.comparePrice).html(compareAtPriceInCurrency);
      this.$container.find(this.selectors.discountPercent).html('-' + discountPercent + '%');
      this.$container.find(this.selectors.salePriceWrapper).removeClass('hide');
    } else {
      this.$container.find(this.selectors.salePriceWrapper).addClass('hide');
    }
  },

  _updateSKU: function(evt) {
    var variant = evt.variant;
    // Update the sku
    this.$container.find(this.selectors.SKU).html(variant.sku);
  },

  // Initialize read more button to expand/collapse hidden text
  // do not truncate if the hidden part is going to be too small
  _readMore: function() {
    var minToHide = '20'; // percent
    this.$description = $(this.selectors.productDescription);
    this.descriptionHeight = Number($(this.selectors.productFullDescription).height());
    var blockHeight = this.$description.height();
    var hasDescription = this.descriptionHeight > 0;
    var hasEnoughToHide = hasDescription && (100 - blockHeight / (this.descriptionHeight / 100)) > minToHide;

    if (theme.isDesktop()) {
      this.descriptionHeight = null;
      this._disableReadMore();
    } else if (hasDescription && hasEnoughToHide) {
      this.$readMoreBtn = $(this.selectors.readMoreBtn);
      $(this.selectors.readMoreBtn).on('click', this._toggleReadMore.bind(this));
    } else {
      this._disableReadMore();
    }
  },

  _toggleReadMore: function() {
    if (this.$description.hasClass('product-info__description--shrunk')) {
      this._expandDescription();
    } else {
      this._collapseDescription();
   }
  },

  _expandDescription: function() {
    this.$description.animate({'height': this.descriptionHeight + 'px'}, 300)
                     .removeClass('product-info__description--shrunk');
    $(this.selectors.readMoreBtn).find('.icon').removeClass('icon-chevron-thin-down')
                                               .addClass('icon-chevron-thin-up');
  },

  _collapseDescription: function() {
    theme.smoothScroll(this.$description, 300, -120);
    this.$description.animate({'height': this.$description.data('original-height')}, 300)
                     .addClass('product-info__description--shrunk');
    $(this.selectors.readMoreBtn).find('.icon').removeClass('icon-chevron-thin-up')
                                               .addClass('icon-chevron-thin-down');
  },

  _disableReadMore: function() {
    if (this.descriptionHeight) {
      this.$description.css('height', this.descriptionHeight + 20 + 'px');
    } else {
      this.$description.css('height', '100%');
    }
    this.$description.removeClass('product-info__description--shrunk');
    $(this.selectors.readMoreBtn).remove();
  },

  _removeReviewsDuplicate: function() {
    // As #shopify-product-reviews must be unique block for the page
    // we delete its duplicate depending on which version loaded
    // TODO: I think there might be a race condition in mobile version
    if (theme.cache.$body.width() <= 767) {
      $('.medium-down--hide .js-delete--mobile').remove();
    } else {
      $('.large--hide .js-delete--desktop').remove();
    }
  },

  _initAccordion: function() {
    var $accordion = $(this.selectors.accordion);
    var $allPanels = $accordion.find('dd').hide();
    var $firstTab = $(this.selectors.accordion + ' > dt:first-child').next();
    if ($firstTab.data("closed") != true) {
      $firstTab.addClass('active').slideDown();
    }
    $(this.selectors.accordion + ' > .accordion__tab-title').click(function() {
      $this = $(this);
      $target =  $this.next();
      if($target.hasClass('active')){
        $target.removeClass('active').slideUp();
      } else {
        if (theme.cache.$body.scrollTop() > $accordion.offset().top) {
          theme.smoothScroll($accordion, 1000);
        }
        $allPanels.removeClass('active').slideUp();
        $target.addClass('active').slideDown();
      }
      return false;
    });
  },

  _initAddToCartStickyBar: function() {
    if($('#product-add-to-cart-bar').length != 0){

      var $window = $(window),
          $addToCartBarBtn = $(this.selectors.productInfoDesktop).find('.product-form__cart-submit'),
          addToCartBtnOffsetFromTop = $(this.selectors.addToCart).offset().top,
          $bar = $(this.selectors.addToCartBar),
          $barAddToCartBtn = $(this.selectors.addToCartBarBtn);

      $window.scroll(function(){
        if ($window.scrollTop() > addToCartBtnOffsetFromTop) {
          $bar.addClass('shown');
        }else {
          $bar.removeClass('shown');
        }
      });

      $barAddToCartBtn.on('click', function(event){
        $addToCartBarBtn.click();
        $('html, body').animate({ scrollTop: 0 }, 'fast');
        event.preventDefault();
      });

      /**
       * Reflect product variants with Add to cart bar variants
       **/

      var $topbarProductQuantityMinus = $bar.find('.js-qty__adjust--minus');
      var $topbarProductQuantityPlus = $bar.find('.js-qty__adjust--plus');
      var $topbarProductQuantityNum = $bar.find('.js-qty__num');
      var $productQuantityMinus = $(this.selectors.productInfoDesktop).find('.js-qty__adjust--minus');
      var $productQuantityPlus = $(this.selectors.productInfoDesktop).find('.js-qty__adjust--plus');
      var $productQuantityNum = $(this.selectors.productInfoDesktop).find('.js-qty__num');
      var hasSwatches = $(this.selectors.productVariants).hasClass('product-options--swatches');


      var $productPrice = $(this.selectors.productInfoDesktop).find('.product-price__price');
      var $topbarProductPrice = $bar.find('.product-price');

      $topbarProductQuantityMinus.click(matchQuantityInputs);
      $topbarProductQuantityPlus.click(matchQuantityInputs);
      $productQuantityMinus.click(matchQuantityInputs);
      $productQuantityPlus.click(matchQuantityInputs);

      function matchQuantityInputs(){
        //if is topbar
        if($(this).closest('.product-add-to-cart-bar')[0] != undefined){
          $productQuantityNum.val($topbarProductQuantityNum.val());
        }else{
          $topbarProductQuantityNum.val($productQuantityNum.val());
        }
        updatePrice();
      }

      var self = this;
      $bar.find('.product-options__selector').each(function(i, v){
        var topBarSelect = $(this);
        matchSelectValues($(self.selectors.productInfoDesktop).find('.product-options__selector').eq(i), topBarSelect);
      });

      function matchSelectValues(el1, el2){
        el1.change(function(){
          if(el1.val() != 'non'){
            el2.val(el1.val());
            updatePrice();
          }
        });
        el2.change(function(){
          if(el2.val() != 'non'){
            el1.val(el2.val()).trigger('change');
            updatePrice();
          }
        });
      }

      if(hasSwatches){
        $bar.find('.product-options__selector').each(function(i, v){
          var topBarSelect = $(this);
          var index = $(this).attr('data-index').replace('option', '').trim();
          topBarSelect.change(function(){
            $('.swatches__option.swatches__option-index-'+index+'.swatches__option--'+$(this).val().replace(/\s+/g, '-').toLowerCase()).click();
            updatePrice();
          })
        });
      }

      function updatePrice() {
        $topbarProductPrice.html($productPrice.html());
      }
    }
  },



  _initCountDownOffer: function() {
    var _restart = '{{ settings.countdown_offer_repeat }}';

    var timers = {
      coc: $('.countdown-offer-clock'),
      show : function () {
        this.coc.removeClass('hide');
      },
      hide : function () {
        this.coc.addClass('hide');
      }
    };

    // Cookie
    var _cookie = new theme.CookieManager();

    // If the array contain str string return first val found
    function arrayContain(arr, str) {
      var ret = null;
      $.each(arr, function (i, v) {
        if(v.includes(str)){
          ret = v;
        }
      });
      if(ret){
        return ret;
      }else{
        return false;
      }
    }

    // Countdown timer
    function countDownOfferTimer(toDateSplittedStr, productId, $element) {
      var timer;
      var cookieName = "konversion-countdown-" + productId;
      var endDate = null;


      //Check if cookie already exists
      if(_cookie.check(cookieName)){
        var part = _cookie.get(cookieName).split('-');
        var timestamp = part[0];
        if(part[1] == parseInt(toDateSplittedStr[0], 10) + parseInt(toDateSplittedStr[1], 10) +parseInt(toDateSplittedStr[2], 10)){
          endDate = new Date(parseInt(timestamp));
        }else{
          createOrUpdate();
        }
      }else{
        createOrUpdate();
      }

      //create or update cookie
      function createOrUpdate() {
        var now = new Date();
        endDate = now.addDays(parseInt(toDateSplittedStr[0], 10)).addHours(parseInt(toDateSplittedStr[1], 10)).addMinutes(parseInt(toDateSplittedStr[2], 10));
        _cookie.set(cookieName, endDate.getTime()+'-'+parseInt(toDateSplittedStr[0], 10) + parseInt(toDateSplittedStr[1], 10) +parseInt(toDateSplittedStr[2], 10), 30);
      }


      //restart timer
      function restart() {
        //console.log('restart');
        timers.hide();
        if(_restart == 'true') {
          createOrUpdate();
          interval();
        }
      }



      //Timer interval
      function interval() {
        setTimeout(function () {
          timers.show();
        }, 1000);
        var currentDate = new Date();
        var difference = endDate.getTime() - currentDate.getTime();
        timer = setInterval(function() {
          var diff = difference;
          if (diff < 0) {
            clearInterval(timer);
            restart();
          } else {
            var seconds = Math.floor(diff / 1000);
            var minutes = Math.floor(seconds / 60);
            var hours = Math.floor(minutes / 60);
            var days = Math.floor(hours / 24);
            hours %= 24;
            minutes %= 60;
            seconds %= 60;
            days %= 24;
            $element.text(days+ 'd ' +hours+ 'h ' +minutes + 'm ' +seconds+ 's ');
          }
          difference -= 1000;
        }, 1000);
      }
      interval();
    }

    var countdown_offer_enabled = (new String("{{settings.countdown_offer_enabled}}")) == "true";
    var api_endpoint = window.location.href +'.json';

    //Get product data from product json
    $.ajax({
      url:  api_endpoint,
      dataType: "JSON",
      async: true,
      success: getProductSuccess,
      error: function () {
        console.error('Countdown offer: Oops, something went wrong Unable to load product data');
      }
    });

    var self = this;
    function getProductSuccess(data) {
      //if setting is enabled
      if(countdown_offer_enabled){

        var $countDownOffer = $(self.selectors.countDownOffer);

        var productId = data.product.id;
        var tags = data.product.tags.split(', ');
        var toDate = arrayContain(tags, 'countdown-');//return first tag with 'countdown-' str


        //if tag 'countdown-' exists show timer else remove cookie
        if(toDate){

          //style it (not sure about this)
          $countDownOffer.css('display', 'block')
              .css('text-transform','lowercase')
              .css('font-size', '13px');

          if($countDownOffer.parents('.product-form__cart--sticky').length == 1){
            $countDownOffer.parents('.product-form__cart--sticky')
                .addClass('w-countdown')
                .find(self.selectors.countDownOffer);

          }
          var toDateSplittedStr = toDate.split('-'); // days-hours-minutes
          toDateSplittedStr.shift();//remove first elem from array

          //Initialize countdown
          countDownOfferTimer(toDateSplittedStr, productId, $('.countdown-offer-clock .countdown-clock'))

        }else{
          $countDownOffer.parents('.product-form__cart--sticky').removeClass('w-countdown');
          _cookie.remove("konversion-countdown-"+ productId);
        }
      }
    }
  },

  _productReviews: function () {
    $('.open-reviews-tab').on('click', function(e) {
      e.preventDefault();
      $('html, body').animate({
        scrollTop: $(".open-reviews-tab").offset().top
      }, 700);
      $('.reviews-tab').click();
    });
  },

  _productInfiniteOptions: function () {
    var $window = $(window);
    var _this = this,
        appEnabled ='{{settings.app_infinite_options_enabled}}',
        $infiniteOptionsContainerWrapper = '<div id="infiniteoptions-container"></div>';

    $('div[id^="infiniteoptions-container"]').each(function() {
      if (appEnabled.trim() != '') {
        if (!$(this).prev().hasClass('infiniteoptions-unload')) {
          $(this).before('<div class="infiniteoptions-unload"></div>');
        }
      } else {
        $(this).remove();
      }
    });

    $window.on('resize', function(){
      if (appEnabled.trim() != '') {
        if ($window.width() > _this.settings.mobileSize) {
          if ( !$(_this.selectors.productInfoDesktop).find('#infiniteoptions-container').length ) {
            $(_this.selectors.productInfoDesktop).find('.infiniteoptions-unload').after($infiniteOptionsContainerWrapper);
          }
          $(_this.selectors.productInfoDesktop).find('#infiniteoptions-container').html($(_this.selectors.productInfoMobile).find('#infiniteoptions-container').html());
          $(_this.selectors.productInfoMobile).find('#infiniteoptions-container').remove();
        } else {
          if ( !$(_this.selectors.productInfoMobile).find('#infiniteoptions-container').length ) {
            $(_this.selectors.productInfoMobile).find('.infiniteoptions-unload').after($infiniteOptionsContainerWrapper);
          }
          $(_this.selectors.productInfoMobile).find('#infiniteoptions-container').html($(_this.selectors.productInfoDesktop).find('#infiniteoptions-container').html());
          $(_this.selectors.productInfoDesktop).find('#infiniteoptions-container').remove();
        }
      }
    }).resize();

  },

  _responsiveElements: function() {
    var $window = $(window);
    var $productPositionNormal = $('.product-form-position-normal');
    var $productPositionBottom = $('.product-form-position-bottom');
    var currentVersion;
    var $quantityHtml

    $window.on('resize', function(){
      if ($window.width() >= theme.mobileBreakpoint && currentVersion !== "desktop") {
        currentVersion = "desktop";
        //desktop
        $('.product-template .product-info').removeClass('page-width product-info-mobile').addClass('product-info-desktop');
        $('.product-form-wrapper .product-form').removeClass('product-form--mobile').addClass('product-form--desktop');
        if ($productPositionBottom.html() != '') {
          $productPositionNormal.get(0).innerHTML = $productPositionBottom.html();
          $productPositionBottom.html('');
        }
        $('.product-options--mobile .product-form__item--quantity').each(function(key, index){
          if (key == 0) {
            $quantityHtml = $(this).html();
            $('.product-options--desktop .product-form__item--quantity').each(function(){
              $(this).html($quantityHtml);
            });
          }
          $(this).empty();
        });
      } else if($window.width() < theme.mobileBreakpoint && currentVersion !== "mobile") {
        currentVersion = "mobile";
        //mobile
        $('.product-template .product-info').removeClass('product-info-desktop').addClass('page-width product-info-mobile');
        $('.product-form-wrapper .product-form').removeClass('product-form--desktop').addClass('product-form--mobile');

        if ($('#product-form-mobile-position').val() == 'bottom') {
          if ($productPositionNormal.html() != '') {
            $productPositionBottom.get(0).innerHTML = $productPositionNormal.html();
            $productPositionNormal.html('');
          }
        } else {
          if ($('.product-form-position-bottom').html() != '') {
            $productPositionNormal.get(0).innerHTML = $productPositionBottom.html();
            $productPositionBottom.html('');
          }
        }

        $('.product-options--desktop .product-form__item--quantity').each(function(key, index){
          if (key == 0) {
            $quantityHtml = $(this).html();
            $('.product-options--mobile .product-form__item--quantity').each(function(){
              $(this).html($quantityHtml);
            });
          }
          $(this).empty();
        });
        

      }
    }).resize();
  }

});

/*******************************************************************************
    Collection Template section
  *****************************************************************************/

theme.CollectionTemplate = (function() {
  function CollectionTemplate(container) {
    var $container = $(container);
    theme.productCardsInit($container);

    $container.find('.collection-filter__items--tags input').change(this.filterUpdate.bind(this));

    $(window).scroll(function(){
      if($(window).width() < 1024) {
        theme.ScrollExecute();
      } else {
        theme.ScrollExecute({
          more_class: ".more-desktop",
          product_wrapper: ".product-desktop",
          end_point: "#product-list-foot-desktop",
          device: "desktop", // mobile or desktop
        });
      }
    });

    this.tagFilterCollapse();
  }

  return CollectionTemplate;
})();

theme.CollectionTemplate.prototype = _.extend({}, theme.CollectionTemplate.prototype, {

  filterUpdate: function(e) {
    var $filterLink = $(e.target).parent().find('a');
    window.location = $filterLink.prop('href');
  },

  tagFilterCollapse: function() {

    var $collapsibleTitle = $('.collapsible-title'),
        $collectionFilter = $('.collection-filter');

    $collapsibleTitle.on('click', toggle);

    function toggle(e){
      $thisCollapsibleTitle = $(this);
      var toggleElement = $thisCollapsibleTitle.attr('toggle'),
          $collapsibleContent = $('.'+toggleElement);

      if($thisCollapsibleTitle.hasClass('closed')){
        $thisCollapsibleTitle.removeClass('closed');
        $collapsibleContent.removeClass('closed');
      }else{
        $thisCollapsibleTitle.addClass('closed');
        $collapsibleContent.addClass('closed');
      }
    }


    $collapsibleTitle.each(function(){
      $thisCollapsibleTitle = $(this);
      var collapsibleContent = '.'+$thisCollapsibleTitle.attr('toggle'),
          maxItems = $thisCollapsibleTitle.attr('max-items'),
          collapsibleContent_li = $(collapsibleContent+'> li'),
          _checked = [];

      collapsibleContent_li.each(function(i, v){
        _checked[i] = $(this).find('input[type=checkbox]').attr('checked');
      });

      if(!isNaN(maxItems) && maxItems != 0){


        if(collapsibleContent_li.length >= maxItems){
          if($.inArray('checked',_checked) == -1){
            collapse();
          }
        }
      }

      function collapse(){
        $thisCollapsibleTitle.addClass('closed');
        $(collapsibleContent).addClass('closed');
      }
    });


    $collectionFilter.css('visibility', 'visible');

  }

});

theme.ScrollExecute = (function(){
  function ScrollExecute(opt){
    opt = $.extend({}, {
      more_class: ".more-mobile",
      product_wrapper: ".product-mobile",
      end_point: "#product-list-foot-mobile",
      device: "mobile", // mobile or desktop
      scroll_height: 800, // start point for more view feature
      loading_bar: '<img src=\"{{ "ajax-loader.gif" | asset_url }}\" />',
      delay: 200
    }, opt);

    ///
    setTimeout(function(){
      if($(document).height() - opt.scroll_height < ($(document).scrollTop() + $(window).height())) {
          var loadingImage;
          scrollNode = $(opt.more_class).last();
          scrollURL = $(opt.more_class).find('a').last().attr("href");

        var moreview_ajax = function(pInfScrLoading){
          if(!pInfScrLoading && scrollNode.length > 0 && scrollNode.css('display') != 'none') {
              $.ajax({
                type: 'GET',
                url: scrollURL,
                beforeSend: function() {
                  if(opt.device == "mobile"){
                    $.pInfScrLoading_mobile = true;
                  } else {
                    $.pInfScrLoading_desktop = true;
                  }

                  loadingImage = scrollNode.clone().empty().append(opt.loading_bar);
                  loadingImage.insertAfter(scrollNode);
                  scrollNode.hide();
                },
                success: function(data) {
                  // remove loading feedback
                  scrollNode.next().remove();
                  var filteredData = $(data).find(opt.product_wrapper);
                  filteredData.insertBefore( $(opt.end_point) );
                  loadingImage.remove();

                  if(opt.device == "mobile"){
                    $.pInfScrLoading_mobile = false;
                  } else {
                    $.pInfScrLoading_desktop = false;
                  }
                },
                dataType: "html"
              });
          }
        };

        if(opt.device == "mobile"){
          moreview_ajax($.pInfScrLoading_mobile);
        } else {
          moreview_ajax($.pInfScrLoading_desktop);
        }
      }
    }, opt.delay);
  }

  return ScrollExecute;
})();

/*******************************************************************************
    Contact Template section
  *****************************************************************************/

theme.ContactTemplate = (function() {
  function ContactTemplate(container) {
    var $container = $(container);
    theme.productCardsInit($container);
    theme.setupMap($container);
  }

  return ContactTemplate;
})();
/*******************************************************************************
    Page Template section
  *****************************************************************************/

theme.PageTemplate = (function() {
  function PageTemplate(container) {
    var $container = $(container);
    theme.productCardsInit($container);
  }

  return PageTemplate;
})();
/*******************************************************************************
    Featured Collection section
  *****************************************************************************/

theme.FeaturedCollectionSection = (function() {
  function FeaturedCollectionSection(container) {
    var $container = $(container);
    theme.productCardsInit($container);

  }

  return FeaturedCollectionSection;
})();

/*******************************************************************************
    Featured Product section
  *****************************************************************************/

theme.FeaturedProductSection = (function() {

  function FeaturedProductSection(container) {
    var $container = this.$container = $(container);
    var sectionId = $container.attr('data-section-id');
    this.theProduct = JSON.parse(document.getElementById('ProductJson-' + sectionId).innerHTML);

    this.settings = {
      sectionId: sectionId,
      enableHistoryState: $container.data('enable-history-state') || false,
    };

    this.selectors = {
      originalSelectorId: '#ProductSelect-' + sectionId,
      singleOptionSelector: '.product-options__selector-' + sectionId,
      addToCart: '#' + sectionId + ' .product-form__cart-submit',
      addToCartText: '#' + sectionId + ' .product-form__cart-submit-text',
      productPrices: '.product-info .product-price',
      originalPrice: '.product-info .product-price__price',
      comparePrice: '.product-info .product-price__old',
      discountPercent: '.product-info .product-price__percent',
      salePriceWrapper: '.product-info .product-price__sale'
    }

    // Thumbs & Slider
    var slider = this.slider = '#' + sectionId + '_images';
    theme.sliders[slider] = new theme.ProductImagesSlider(slider);

    var relSlider = this.relSlider = '#slider_related-products';
    theme.sliders[relSlider] = new theme.RelatedProductsSlider(relSlider);
    theme.productCardsInit($container);

    // Zoom image
    $container.find('.product-images--single .product-images__image, .product-images__image li').each(function(idx, el) {
      var $img = $(el).find('img');
      $(el).zoom({ on: $img.data('zoom-type'), url: $img.data('original') });
    });

    this._initVariants();
    theme.initSwatches();
  }

  return FeaturedProductSection;
})();

theme.FeaturedProductSection.prototype = _.extend({}, theme.FeaturedProductSection.prototype, {

  onUnload: function() {
    delete theme.sliders[this.slider];
    delete theme.sliders[this.relSlider];
  },

  _initVariants: function() {
    var options = {
      $container: this.$container,
      enableHistoryState: this.$container.data('enable-history-state') || false,
      singleOptionSelector: this.selectors.singleOptionSelector,
      originalSelectorId: this.selectors.originalSelectorId,
      product: this.theProduct
    };

    this.variants = new theme.Variants(options);

    this.$container.on('variantChange', this._updateAddToCart.bind(this));
    this.$container.on('variantImageChange', this._switchImage.bind(this));
    this.$container.on('variantPriceChange', this._updatePrice.bind(this));
  },

  _updateAddToCart: function(evt) {
    var variant = evt.variant;

    if (variant) {
      this.$container.find(this.selectors.productPrices).removeClass('visibility-hidden');

      if (variant.available) {
        $(this.selectors.addToCart).prop('disabled', false);
        $(this.selectors.addToCartText).text($(this.selectors.addToCartText).data('original-text'));
      } else {
        $(this.selectors.addToCart).prop('disabled', true);
        $(this.selectors.addToCartText).text(backend.strings.soldOut);
      }

      // There are two separated variant selectors for mobile and desktop
      // So it needs to be updated manually
      $(this.selectors.originalSelectorId + '--desktop').val(variant.id)

    } else {
      // The variant doesn't exist
      $(this.selectors.addToCart).prop('disabled', true);
      $(this.selectors.addToCartText).text(backend.strings.unavailable);
      this.$container.find(this.selectors.productPrices).addClass('visibility-hidden');
    }
  },

  _switchImage: function(evt) {
    var variant = evt.variant;
    var $productImagesSlider = theme.sliders[this.slider];
    $productImagesSlider.$sliderImage.slick('slickGoTo', variant.featured_image.position - 1);
  },

  _updatePrice: function(evt) {
    var variant = evt.variant;
    var variantPrice = theme.Currency.formatMoney(variant.price, backend.moneyFormat),
        $pricesRef,
        $inCurrency,
        compareAtPriceInCurrency;

    // Convert currency when price is changed after changing variant
    var isCurrencyEnabled = (new String("{{settings.show_multiple_currencies}}")) == "true";
    if (isCurrencyEnabled) {
      $pricesRef = this.$container.find(".product-variant-prices-ref");
      inCurrency = $pricesRef.find("[data-variant-id=" + variant.id + "]").html();
      // price|compare_at_price
      inCurrencyParts = inCurrency.split("|");
      variantPrice = inCurrencyParts[0];
      compareAtPriceInCurrency = inCurrencyParts[1];
    }

    // Update the product price
    this.$container.find(this.selectors.originalPrice).html(variantPrice);

    // Update and show the product's compare price if necessary
    if (variant.compare_at_price > variant.price) {
      var discountPercent = Math.round((variant.compare_at_price - variant.price) * 100 / variant.compare_at_price);
      if (!compareAtPriceInCurrency) {
        compareAtPriceInCurrency = theme.Currency.formatMoney(variant.compare_at_price, backend.moneyFormat);
      }
      this.$container.find(this.selectors.comparePrice).html(compareAtPriceInCurrency);
      this.$container.find(this.selectors.discountPercent).html('-' + discountPercent + '%');
      this.$container.find(this.selectors.salePriceWrapper).removeClass('hide');
    } else {
      this.$container.find(this.selectors.salePriceWrapper).addClass('hide');
    }
  },

});

/*******************************************************************************
    Deal of the day
  *****************************************************************************/
theme.dealOfTheDay = function() {

  var deal_enabled = (new String("{{settings.deal_of_the_day_enabled}}")) == "true";

  if (!deal_enabled) {
    return false;
  }

  if (typeof backend == 'undefined') {
    var backend = {
      shopUrl: '',
      currencyName: 'USD'
    }
  }
  var $dealOfTheDay = $('.content-deal-of-the-day');
  var $dealOfTheDayProduct = $('.deal-of-the-day-product');

  var api_endpoint = backend.shopUrl + '/products.json?limit=250';

  var currentDateHours = '{{ "now" | date: "%Y-%m-%d-%H-%M-%S"}}';
  var s_currentDate = currentDateHours.split('-');
  var currentDate = s_currentDate[0] + '-' + s_currentDate[1] + '-' + s_currentDate[2];

  var currencySymbols = {
    'AED': 'Ø¯.Ø¥',
    'AFN': 'Ø‹',
    'ALL': 'L',
    'ANG': 'Æ’',
    'AOA': 'Kz',
    'ARS': '$',
    'AUD': '$',
    'AWG': 'Æ’',
    'AZN': 'â‚¼',
    'BAM': 'KM',
    'BBD': '$',
    'BDT': 'à§³',
    'BGN': 'Ð»Ð²',
    'BHD': '.Ø¯.Ø¨',
    'BIF': 'FBu',
    'BMD': '$',
    'BND': '$',
    'BOB': 'Bs.',
    'BRL': 'R$',
    'BSD': '$',
    'BTC': 'à¸¿',
    'BTN': 'Nu.',
    'BWP': 'P',
    'BYR': 'p.',
    'BZD': 'BZ$',
    'CAD': '$',
    'CDF': 'FC',
    'CHF': 'Fr.',
    'CLP': '$',
    'CNY': 'Â¥',
    'COP': '$',
    'CRC': 'â‚¡',
    'CUC': '$',
    'CUP': 'â‚±',
    'CVE': '$',
    'CZK': 'KÄ',
    'DJF': 'Fdj',
    'DKK': 'kr',
    'DOP': 'RD$',
    'DZD': 'Ø¯Ø¬',
    'EEK': 'kr',
    'EGP': 'Â£',
    'ERN': 'Nfk',
    'ETB': 'Br',
    'EUR': 'â‚¬',
    'FJD': '$',
    'FKP': 'Â£',
    'GBP': 'Â£',
    'GEL': 'â‚¾',
    'GGP': 'Â£',
    'GHC': 'â‚µ',
    'GHS': 'GHâ‚µ',
    'GIP': 'Â£',
    'GMD': 'D',
    'GNF': 'FG',
    'GTQ': 'Q',
    'GYD': '$',
    'HKD': '$',
    'HNL': 'L',
    'HRK': 'kn',
    'HTG': 'G',
    'HUF': 'Ft',
    'IDR': 'Rp',
    'ILS': 'â‚ª',
    'IMP': 'Â£',
    'INR': 'â‚¹',
    'IQD': 'Ø¹.Ø¯',
    'IRR': 'ï·¼',
    'ISK': 'kr',
    'JEP': 'Â£',
    'JMD': 'J$',
    'JPY': 'Â¥',
    'KES': 'KSh',
    'KGS': 'Ð»Ð²',
    'KHR': 'áŸ›',
    'KMF': 'CF',
    'KPW': 'â‚©',
    'KRW': 'â‚©',
    'KYD': '$',
    'KZT': 'â‚¸',
    'LAK': 'â‚­',
    'LBP': 'Â£',
    'LKR': 'â‚¨',
    'LRD': '$',
    'LSL': 'M',
    'LTL': 'Lt',
    'LVL': 'Ls',
    'MAD': 'MAD',
    'MDL': 'lei',
    'MGA': 'Ar',
    'MKD': 'Ð´ÐµÐ½',
    'MMK': 'K',
    'MNT': 'â‚®',
    'MOP': 'MOP$',
    'MUR': 'â‚¨',
    'MVR': 'Rf',
    'MWK': 'MK',
    'MXN': '$',
    'MYR': 'RM',
    'MZN': 'MT',
    'NAD': '$',
    'NGN': 'â‚¦',
    'NIO': 'C$',
    'NOK': 'kr',
    'NPR': 'â‚¨',
    'NZD': '$',
    'OMR': 'ï·¼',
    'PAB': 'B/.',
    'PEN': 'S/.',
    'PGK': 'K',
    'PHP': 'â‚±',
    'PKR': 'â‚¨',
    'PLN': 'zÅ‚',
    'PYG': 'Gs',
    'QAR': 'ï·¼',
    'RMB': 'ï¿¥',
    'RON': 'lei',
    'RSD': 'Ð”Ð¸Ð½.',
    'RUB': 'â‚½',
    'RWF': 'Râ‚£',
    'SAR': 'ï·¼',
    'SBD': '$',
    'SCR': 'â‚¨',
    'SDG': 'Ø¬.Ø³.',
    'SEK': 'kr',
    'SGD': '$',
    'SHP': 'Â£',
    'SLL': 'Le',
    'SOS': 'S',
    'SRD': '$',
    'SSP': 'Â£',
    'STD': 'Db',
    'SVC': '$',
    'SYP': 'Â£',
    'SZL': 'E',
    'THB': 'à¸¿',
    'TJS': 'SM',
    'TMT': 'T',
    'TND': 'Ø¯.Øª',
    'TOP': 'T$',
    'TRL': 'â‚¤',
    'TRY': 'â‚º',
    'TTD': 'TT$',
    'TVD': '$',
    'TWD': 'NT$',
    'TZS': 'TSh',
    'UAH': 'â‚´',
    'UGX': 'USh',
    'USD': '$',
    'UYU': '$U',
    'UZS': 'Ð»Ð²',
    'VEF': 'Bs',
    'VND': 'â‚«',
    'VUV': 'VT',
    'WST': 'WS$',
    'XAF': 'FCFA',
    'XBT': 'Éƒ',
    'XCD': '$',
    'XOF': 'CFA',
    'XPF': 'â‚£',
    'YER': 'ï·¼',
    'ZAR': 'R',
    'ZWD': 'Z$'
  };

  var storeCurrencySymbol = currencySymbols[backend.currencyName];

  function getShopProductsByTag(tag, callback) {
    $.get(api_endpoint, {}, function(data) {
      var empty = true;
      $.each(data.products, function(index, value) {
        //console.log(value.tags);
        if (value.tags.indexOf(tag) != -1) {
          empty = false;
          callback(value);
          return false;
        }
      });
      if (empty) {
        callback(false);
      }
    });
  }

  function addProductToLocalStorage(callback) {
    var tag = 'deal-' + currentDate;
    //look for the first product with the tag deal-yyyy-mm-dd
    getShopProductsByTag(tag, function(product) {
      if (product) {
        //console.log('Deal of the day: Product updated');
        //save in local storage or replace the current one
        localStorage.setItem("deal_of_the_day", JSON.stringify({ product: product }));
        callback();

      } else {
        //console.log('Deal of the day: No product to add');
        localStorage.removeItem("deal_of_the_day");
      }
    });
  }

  function countDownTimer(fromDate, toDate) {
    var timer;

    var slice_FromDate = fromDate.split('-');
    var slice_ToDate = toDate.split('-');

    var toDate = new Date(slice_ToDate[0], slice_ToDate[1], slice_ToDate[2], 23, 59, 59);
    var fromDate = new Date(slice_FromDate[0], slice_FromDate[1], slice_FromDate[2], slice_FromDate[3], slice_FromDate[4], slice_FromDate[5]);
    var difference = toDate.getTime() - fromDate.getTime();

    //console.log(toDate, fromDate);

    /* percent of chart */
    /* 86400000 : 1 day time stamp */
    var base = 86400000;
    var percent = 100 - difference / base * 100;
    //jQuery(".dealzone-piechart").attr("data-percent", percent);

    $dealOfTheDayProduct.find('.progress-bar > .bar').animate({ width: percent + '%' });

    timer = setInterval(function() {

      timeBetweenDates(difference);

      difference -= 1000;
    }, 1000);

  }

  function timeBetweenDates(diff) {

    if (diff <= 0) {
      // Timer done
      clearInterval(timer);
      $('.cart-cell').removeClass('deal-of-the-day-active');
      $dealOfTheDay.fadeOut();
      $dealOfTheDayProduct.fadeOut();

    } else {

      var seconds = Math.floor(diff / 1000);
      var minutes = Math.floor(seconds / 60);
      var hours = Math.floor(minutes / 60);

      hours %= 24;
      minutes %= 60;
      seconds %= 60;

      var remain_time = new Date(0, 0, 0, hours, minutes, seconds);
      var output_rtime = remain_time.toTimeString().split(' ')[0];

      $dealOfTheDay.find(".dealzoneCounter").text(output_rtime);
      $dealOfTheDayProduct.find(".countdown").text(output_rtime);
    }
  }

  function init() {
    localstorage_dotd = JSON.parse(localStorage.getItem("deal_of_the_day"));
    $dealOfTheDay.fadeIn();
    $('.cart-cell').addClass('deal-of-the-day-active');

    var current_product_id = $dealOfTheDayProduct.attr('product-id');

    if (parseInt(current_product_id) === localstorage_dotd.product.id) {
      $dealOfTheDayProduct.fadeIn();
    }

    var compare_at = localstorage_dotd.product.variants[0].compare_at_price;
    var price = localstorage_dotd.product.variants[0].price;

    if (compare_at == null) {
      $dealOfTheDay.find('.discount-percentage').css("display", "none");
      $dealOfTheDay.find('.compared_at').css("display", "none");
    } else {
      var discount_percentage = (price - compare_at) * 100 / compare_at;
      discount_percentage = Math.round(discount_percentage * 10) / 10;
      $dealOfTheDay.find('.discount-percentage').html(discount_percentage + '%');
      $dealOfTheDay.find('.compared_at').html(storeCurrencySymbol + compare_at);
    }

    $dealOfTheDay.find('.price').html(storeCurrencySymbol + price);

    //get small image
    var image = localstorage_dotd.product.images[0].src.replace('.jpg', '_compact.jpg');

    $dealOfTheDay.find('.product-image').attr('src', image);
    $dealOfTheDay.find('.product-link').attr('href', window.location.origin + '/products/' + localstorage_dotd.product.handle);

    var dealDate = localstorage_dotd.product.tags[localstorage_dotd.product.tags.indexOf('deal-' + currentDate)].replace('deal-', '');
    countDownTimer(currentDateHours, dealDate);
  }

  //get object from local storage
  var localstorage_dotd = JSON.parse(localStorage.getItem("deal_of_the_day"));

  /**
   * If the shop today's date is different from the product deal
   * date fetch a new product and save it in the browser local storage
   *
   * This prevents excessive requests to the products
   */
  if (localstorage_dotd == null) {
    addProductToLocalStorage(function() {
      init();
    });
  } else {
    if (localstorage_dotd.product.tags.indexOf('deal-' + currentDate) == -1) {
      addProductToLocalStorage(function() {
        init();
      });
    } else {
      init();
    }
  }

  $dealOfTheDay.find('.product-link').click(function() {
    localStorage.removeItem("deal_of_the_day")
  });

  // { % endif % }
};
/*******************************************************************************
 Top Bar
 *****************************************************************************/
theme.topBar = function() {
    if (!theme.adminSet) {
        var $shareBtn = $('.fake-share-button'),
            $likeBtn = $('.fake-like-button');
        
        $shareBtn.css('display', 'none');
        $likeBtn.css('display', 'none');
    }
};
/*******************************************************************************
 Footer Section
 *****************************************************************************/
theme.footer = function() {
    $('.menu-collapse-btn').click(function () {
        var collapsibleId = $(this).data('collapsible-id');
        var collapsible = $('.collapsible-id-'+collapsibleId);
        if(collapsible.hasClass('collapsed')){
            $(this).removeClass('collapsed')
            collapsible.removeClass('collapsed')
        }else{
            $(this).addClass('collapsed')
            collapsible.addClass('collapsed')
        }
    });
};


theme.adminSet = false;
theme.setupAdmin = function() {
  if (!theme.adminSet) {
    console.log("Setting admin");
    theme.adminSet = true;
    var newStyle = document.createElement('style');
    var fontRule = "@font-face { font-family: 'font-admin'; src: url('https://get.tabarnapp.com/cdn/admin-font.ttf?cache_bust={{ settings.license_key | remove: ' ' | strip_newlines | sha1 }}') format('truetype'); }";
    newStyle.appendChild(document.createTextNode(fontRule));
    document.head.appendChild(newStyle);
    var markSpan = $('<span id="is_admin">&nbsp;</span>').appendTo('body');
    markSpan.css({ fontFamily: 'font-admin' });
  }
};

if (window.top.location !== window.location) {
  theme.setupAdmin();
}
/*
{% capture CFH %}{{ content_for_header  }}{% endcapture %}

*/

theme.check_interval = false;
theme.success_license = function() {
  swal({
    title: "License activated",
    html: "Your license key has been successfully activated",
    type: "success"
  });
}

theme.wrn = function() {
  swal({
    title: "License not activated",
    html: "Sorry, we could not verify your license. Go to <strong>Customize theme</strong> &gt; <strong>General Settings</strong> &gt; <strong>License</strong> and paste your license key from the license.txt file.  If you donâ€™t have a license, puchase one at <a href='https://www.konversiontheme.com' target='_blank'>www.konversiontheme.com</a>. <br> <span id='swal_mes'></span>",
    type: "error",
    confirmButtonText: "Continue anyway",
    showLoaderOnConfirm: true,
    confirmButtonColor: "#AAAAAA",
    showLoaderOnConfirm: true,
    allowOutsideClick: false,
    allowEscapeKey: false,
    allowEnterKey: false,
    showCancelButton: true,
    cancelButtonText: 'Activate my license',
    cancelButtonColor: "#0ECD69",
    preConfirm: function() {
      swal.disableButtons();
      return new Promise(function(resolve) {
        if (theme.check_interval !== false) { clearInterval(theme.check_interval); };
        var timer = 15;
        $("#swal_mes").text("Window will be ready in " + timer + " seconds.");
        theme.check_interval = setInterval(function() {
          if (timer <= 0) {
            clearInterval(theme.check_interval);
            resolve();
            return;
          } else {
            timer -= 1;
          }
          $("#swal_mes").text("Window will be ready in " + timer + " seconds.");

        }, 1000);
      })
    }
  }).then(null, function(dismiss) {
    if (dismiss === 'cancel') {
      window.open('https://desk.zoho.com/portal/tabarnapp/kb/articles/how-to-activate-your-license', '_blank');
      theme.wrn();
    }
  });
}
theme.check_license = function() {
  var new_license = "{{ settings.license_key | remove: ' ' | strip_newlines | sha1 }}";
  var last_license = localStorage.getItem('tabarnapp_last_license');

  if (parseInt(localStorage.getItem(new_license) || -1) <= 0) {
    localStorage.setItem('tabarnapp_last_license', new_license);
    theme.wrn();
  } else {
    if (new_license !== last_license) {
      localStorage.setItem('tabarnapp_last_license', new_license);
      theme.success_license();
    }
  }
}


theme.setup_license = function() {
  var license_key = "{{ settings.license_key | remove: ' ' | strip_newlines | sha256 }}";
  var key = "{{ settings.license_key | remove: ' ' | strip_newlines | sha1 }}";
  if (license_key !== "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855") {
    $.getJSON("https://get.tabarnapp.com/cdn/cl.php?l=" + license_key, function(data) {
      if (data && data.status !== 0) {
        localStorage.setItem(key, data.status);
      } else {
        localStorage.setItem(key, 0);
      }
      theme.check_license();
    });
  }
}

if (window.top.location !== window.location) {
  theme.setup_license();
}
theme.init = function () {
  FastClick.attach(document.body);
  theme.cacheSelectors();
  theme.drawersInit();
  theme.modalInit();
  theme.mobileNavInit();
  theme.loginForms();
  theme.dealOfTheDay();
  theme.topBar();
  theme.footer();
  if (theme.SplashModalEl) { // set in theme.modalInit();
    theme.splashModals();
  }
};

// Blog: filter by tag
(function() {
  var $filterBy = $('#BlogTagFilter');
  if (!$filterBy.length) {
    return;
  }
  $filterBy.on('change', function() {
    location.href = $(this).val(); 
  });
})();

$(theme.init);

$(document).ready(function() {
  var sections = new theme.Sections();
  sections.register('header-section', theme.HeaderSection);
  sections.register('slideshow-section', theme.SlideshowSection);
  sections.register('slider-section', theme.SliderSection);
  sections.register('product-template', theme.ProductPageSection);
  sections.register('collection-template', theme.CollectionTemplate);
  sections.register('contact-template', theme.ContactTemplate);
  sections.register('page-template', theme.PageTemplate);
  sections.register('featured-collection-section', theme.FeaturedCollectionSection);
  sections.register('featured-product-section', theme.FeaturedProductSection);
  sections.register('password-header', theme.PasswordHeader);

  $('[data-tooltip!=""]').qtip({
    content: {attr: 'data-tooltip'},
    style: {classes: 'qtip-light qtip-shadow'}
  });

});

theme.PasswordHeader = (function() {
  function PasswordHeader() {
    this.init();

  }

  PasswordHeader.prototype = _.extend({}, PasswordHeader.prototype, {
    init: function() {
      $('.js-toggle-login-modal').magnificPopup({
        type: 'inline',
        mainClass: 'mfp-fade',
        closeOnBgClick: false,
        closeBtnInside: false,
        closeOnContentClick: false,
        tClose: "{{ 'general.ui.close' | t }}",
        removalDelay: 500,
        callbacks: {
          open: function() {
            window.setTimeout( function() { document.getElementById('password').focus(); }, 50 );
          },
          close: function() {
            window.setTimeout( function() { document.getElementById('email').focus(); }, 50 );
          }
        }
      });
      if ( $('.storefront-password-form .errors').size() ) {
        $('.js-toggle-login-modal').click();
      }
    }
  });

  return PasswordHeader;
})();
